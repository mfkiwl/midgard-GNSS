{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Installing Midgard Midgard is available at PyPI . You can install it by simply running python -m pip install midgard Installing Midgard from source Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, etc. We recommend using the Anaconda distribution to ease the installation of these dependencies. Install Anaconda Go to www.anaconda.com/download , and download Anaconda for Python 3. Download the Midgard source code If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard Install dependencies You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard Install the Midgard package To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file Using Midgard Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Home"},{"location":"#midgard-the-python-geodesy-library","text":"Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting.","title":"Midgard, the Python Geodesy library"},{"location":"#installing-midgard","text":"Midgard is available at PyPI . You can install it by simply running python -m pip install midgard","title":"Installing Midgard"},{"location":"#installing-midgard-from-source","text":"Midgard depends on several other brilliant Python packages, like for instance numpy, scipy, etc. We recommend using the Anaconda distribution to ease the installation of these dependencies.","title":"Installing Midgard from source"},{"location":"#install-anaconda","text":"Go to www.anaconda.com/download , and download Anaconda for Python 3.","title":"Install Anaconda"},{"location":"#download-the-midgard-source-code","text":"If you have not already done so, download the Midgard source code from Github: github.com/kartverket/midgard . Then enter the main midgard directory before running the install command below. cd midgard","title":"Download the Midgard source code"},{"location":"#install-dependencies","text":"You should now install the necessary dependencies using the environment.yml -file. You can do this either in your current conda environment, or choose to create a new midgard -environment. In order to use midgard in other projects you need to install midgard in the same environment as those projects. To install midgard in your current environment, do conda env update -f environment.yml To install midgard in a new environment named midgard and activate it, do conda env create -n midgard -f environment.yml conda activate midgard","title":"Install dependencies"},{"location":"#install-the-midgard-package","text":"To do the actual installation of Midgard, use the flit packaging tool: python -m flit install --dep production If you want to develop the Midgard package, install it in editable mode using python -m flit install -s On Windows, you can install in editable mode using python -m flit install --pth-file","title":"Install the Midgard package"},{"location":"#using-midgard","text":"Midgard comes organized into different subpackages. To see info about the different subpackages, use the Python help system: >>> import midgard >>> help(midgard) Information about individual subpackages is also available on the Midgard website .","title":"Using Midgard"},{"location":"api/midgard-collections/","text":"midgard.collections midgard.collections.enums Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. References: [1] RINEX Version 3.04 (2018): RINEX The receiver independent exchange format version 3.04, November 23, 2018 Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2 BeidouFreqNum2Freq Full name: midgard.collections.enums.BeidouFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. BeidouFrequency Full name: midgard.collections.enums.BeidouFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz ExitStatus Full name: midgard.collections.enums.ExitStatus Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition GPSFrequency Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz GalileoFreqNum2Freq Full name: midgard.collections.enums.GalileoFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. GalileoFrequency Full name: midgard.collections.enums.GalileoFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz GlonassFreqNum2Freq Full name: midgard.collections.enums.GlonassFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. Gnss3DigitIdToId Full name: midgard.collections.enums.Gnss3DigitIdToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier GnssIdTo3DigitId Full name: midgard.collections.enums.GnssIdTo3DigitId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier GnssIdToName Full name: midgard.collections.enums.GnssIdToName Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name GnssIdToReferenceSystem Full name: midgard.collections.enums.GnssIdToReferenceSystem Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name GnssNameToId Full name: midgard.collections.enums.GnssNameToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier GpsFreqNum2Freq Full name: midgard.collections.enums.GpsFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. IrnssFreqNum2Freq Full name: midgard.collections.enums.IrnssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. IrnssFrequency Full name: midgard.collections.enums.IrnssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz LogColor Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging LogLevel Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show NotGiven Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value QzssFreqNum2Freq Full name: midgard.collections.enums.QzssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. QzssFrequency Full name: midgard.collections.enums.QzssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz SbasFreqNum2Freq Full name: midgard.collections.enums.SbasFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. SbasFrequency Full name: midgard.collections.enums.SbasFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz WriteLevel Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk enums () Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums. exit_status Full name: midgard.collections.enums.exit_status Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition get_enum () Full name: midgard.collections.enums.get_enum Signature: (name: str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name. get_value () Full name: midgard.collections.enums.get_value Signature: (name: str, value: str, default: Any = <class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name. gnss_3digit_id_to_id Full name: midgard.collections.enums.gnss_3digit_id_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier gnss_freq_C Full name: midgard.collections.enums.gnss_freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz gnss_freq_E Full name: midgard.collections.enums.gnss_freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz gnss_freq_G Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz gnss_freq_I Full name: midgard.collections.enums.gnss_freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz gnss_freq_J Full name: midgard.collections.enums.gnss_freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz gnss_freq_S Full name: midgard.collections.enums.gnss_freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz gnss_id_to_3digit_id Full name: midgard.collections.enums.gnss_id_to_3digit_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier gnss_id_to_name Full name: midgard.collections.enums.gnss_id_to_name Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name gnss_id_to_reference_system Full name: midgard.collections.enums.gnss_id_to_reference_system Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name gnss_name_to_id Full name: midgard.collections.enums.gnss_name_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier gnss_num2freq_C Full name: midgard.collections.enums.gnss_num2freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_E Full name: midgard.collections.enums.gnss_num2freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_G Full name: midgard.collections.enums.gnss_num2freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_I Full name: midgard.collections.enums.gnss_num2freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_J Full name: midgard.collections.enums.gnss_num2freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_R Full name: midgard.collections.enums.gnss_num2freq_R Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. gnss_num2freq_S Full name: midgard.collections.enums.gnss_num2freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration. has_value () Full name: midgard.collections.enums.has_value Signature: (name: str, value: str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise log_color Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging log_level Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show register_enum () Full name: midgard.collections.enums.register_enum Signature: (name: str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration. write_level Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollections","text":"","title":"midgard.collections"},{"location":"api/midgard-collections/#midgardcollectionsenums","text":"Framework for working with enumerations Description: Custom enumerations used for structured names. You can add your own enumerations in your own application by importing register_enum and using that to register your own enums. References: [1] RINEX Version 3.04 (2018): RINEX The receiver independent exchange format version 3.04, November 23, 2018 Example: Create your own enumeration: from midgard.collections.enums import register_enum @register_enum(\"reference_ellipsoid\") class ReferenceEllipsoid(enum.IntEnum): wgs84 = 1 grs80 = 2 wgs72 = 3 Use enumerations in your code: from midgard.collections import enums enums.get_value(\"gnss_freq_G\", \"L1\") enums.get_value(\"gnss_freq_G\", \"L1\") + 1 enums.get_enum(\"gnss_freq_G\") enums.get_enum(\"gnss_freq_G\").L1 enums.get_enum(\"gnss_freq_G\").L1 + 1 enums.gnss_freq_G.L1 enums.gnss_freq_G.L1 * 2","title":"midgard.collections.enums"},{"location":"api/midgard-collections/#beidoufreqnum2freq","text":"Full name: midgard.collections.enums.BeidouFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"BeidouFreqNum2Freq"},{"location":"api/midgard-collections/#beidoufrequency","text":"Full name: midgard.collections.enums.BeidouFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz","title":"BeidouFrequency"},{"location":"api/midgard-collections/#exitstatus","text":"Full name: midgard.collections.enums.ExitStatus Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition","title":"ExitStatus"},{"location":"api/midgard-collections/#gpsfrequency","text":"Full name: midgard.collections.enums.GPSFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz","title":"GPSFrequency"},{"location":"api/midgard-collections/#galileofreqnum2freq","text":"Full name: midgard.collections.enums.GalileoFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GalileoFreqNum2Freq"},{"location":"api/midgard-collections/#galileofrequency","text":"Full name: midgard.collections.enums.GalileoFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz","title":"GalileoFrequency"},{"location":"api/midgard-collections/#glonassfreqnum2freq","text":"Full name: midgard.collections.enums.GlonassFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GlonassFreqNum2Freq"},{"location":"api/midgard-collections/#gnss3digitidtoid","text":"Full name: midgard.collections.enums.Gnss3DigitIdToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier","title":"Gnss3DigitIdToId"},{"location":"api/midgard-collections/#gnssidto3digitid","text":"Full name: midgard.collections.enums.GnssIdTo3DigitId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier","title":"GnssIdTo3DigitId"},{"location":"api/midgard-collections/#gnssidtoname","text":"Full name: midgard.collections.enums.GnssIdToName Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name","title":"GnssIdToName"},{"location":"api/midgard-collections/#gnssidtoreferencesystem","text":"Full name: midgard.collections.enums.GnssIdToReferenceSystem Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name","title":"GnssIdToReferenceSystem"},{"location":"api/midgard-collections/#gnssnametoid","text":"Full name: midgard.collections.enums.GnssNameToId Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier","title":"GnssNameToId"},{"location":"api/midgard-collections/#gpsfreqnum2freq","text":"Full name: midgard.collections.enums.GpsFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"GpsFreqNum2Freq"},{"location":"api/midgard-collections/#irnssfreqnum2freq","text":"Full name: midgard.collections.enums.IrnssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"IrnssFreqNum2Freq"},{"location":"api/midgard-collections/#irnssfrequency","text":"Full name: midgard.collections.enums.IrnssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz","title":"IrnssFrequency"},{"location":"api/midgard-collections/#logcolor","text":"Full name: midgard.collections.enums.LogColor Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"LogColor"},{"location":"api/midgard-collections/#loglevel","text":"Full name: midgard.collections.enums.LogLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"LogLevel"},{"location":"api/midgard-collections/#notgiven","text":"Full name: midgard.collections.enums.NotGiven Signature: () Dummy class used as a marker for a argument not given, used instead of None because None is valid value","title":"NotGiven"},{"location":"api/midgard-collections/#qzssfreqnum2freq","text":"Full name: midgard.collections.enums.QzssFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"QzssFreqNum2Freq"},{"location":"api/midgard-collections/#qzssfrequency","text":"Full name: midgard.collections.enums.QzssFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz","title":"QzssFrequency"},{"location":"api/midgard-collections/#sbasfreqnum2freq","text":"Full name: midgard.collections.enums.SbasFreqNum2Freq Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"SbasFreqNum2Freq"},{"location":"api/midgard-collections/#sbasfrequency","text":"Full name: midgard.collections.enums.SbasFrequency Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz","title":"SbasFrequency"},{"location":"api/midgard-collections/#writelevel","text":"Full name: midgard.collections.enums.WriteLevel Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"WriteLevel"},{"location":"api/midgard-collections/#enums","text":"Full name: midgard.collections.enums.enums Signature: () -> List[str] Return a list of available enums Returns: Names of available enums.","title":"enums()"},{"location":"api/midgard-collections/#exit_status","text":"Full name: midgard.collections.enums.exit_status Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Exit status definition","title":"exit_status"},{"location":"api/midgard-collections/#get_enum","text":"Full name: midgard.collections.enums.get_enum Signature: (name: str) -> enum.EnumMeta Return a named Enumeration Names are defined by the @register_enum-decorator. If the name-parameter is not a valid enum, the function will raise an UnknownEnumError and list the available enumerations. Args: name : Name used for Enumeration. Returns: Enumeration with the given name.","title":"get_enum()"},{"location":"api/midgard-collections/#get_value","text":"Full name: midgard.collections.enums.get_value Signature: (name: str, value: str, default: Any = <class 'midgard.collections.enums.NotGiven'>) -> enum.Enum Return the value of a named Enumeration Names are defined by the @register_enum-decorator. Args: name : Name used for Enumeration. value : Value of Enumeration. default : Optional object returned if enumeration does not contain value Returns: Value of enumeration with the given name.","title":"get_value()"},{"location":"api/midgard-collections/#gnss_3digit_id_to_id","text":"Full name: midgard.collections.enums.gnss_3digit_id_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS 3-digit identifier to RINEX GNSS identifier","title":"gnss_3digit_id_to_id"},{"location":"api/midgard-collections/#gnss_freq_c","text":"Full name: midgard.collections.enums.gnss_freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) BeiDou frequencies in Hz","title":"gnss_freq_C"},{"location":"api/midgard-collections/#gnss_freq_e","text":"Full name: midgard.collections.enums.gnss_freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Galileo frequencies in Hz","title":"gnss_freq_E"},{"location":"api/midgard-collections/#gnss_freq_g","text":"Full name: midgard.collections.enums.gnss_freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GPS frequencies in Hz","title":"gnss_freq_G"},{"location":"api/midgard-collections/#gnss_freq_i","text":"Full name: midgard.collections.enums.gnss_freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) IRNSS frequencies in Hz","title":"gnss_freq_I"},{"location":"api/midgard-collections/#gnss_freq_j","text":"Full name: midgard.collections.enums.gnss_freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) QZSS frequencies in Hz","title":"gnss_freq_J"},{"location":"api/midgard-collections/#gnss_freq_s","text":"Full name: midgard.collections.enums.gnss_freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) SBAS frequencies in Hz","title":"gnss_freq_S"},{"location":"api/midgard-collections/#gnss_id_to_3digit_id","text":"Full name: midgard.collections.enums.gnss_id_to_3digit_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to GNSS 3-digit identifier","title":"gnss_id_to_3digit_id"},{"location":"api/midgard-collections/#gnss_id_to_name","text":"Full name: midgard.collections.enums.gnss_id_to_name Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS identifier to GNSS name","title":"gnss_id_to_name"},{"location":"api/midgard-collections/#gnss_id_to_reference_system","text":"Full name: midgard.collections.enums.gnss_id_to_reference_system Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) RINEX GNSS RINEX identifier to relevant GNSS reference system name","title":"gnss_id_to_reference_system"},{"location":"api/midgard-collections/#gnss_name_to_id","text":"Full name: midgard.collections.enums.gnss_name_to_id Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) GNSS name to RINEX GNSS identifier","title":"gnss_name_to_id"},{"location":"api/midgard-collections/#gnss_num2freq_c","text":"Full name: midgard.collections.enums.gnss_num2freq_C Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_C"},{"location":"api/midgard-collections/#gnss_num2freq_e","text":"Full name: midgard.collections.enums.gnss_num2freq_E Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_E"},{"location":"api/midgard-collections/#gnss_num2freq_g","text":"Full name: midgard.collections.enums.gnss_num2freq_G Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_G"},{"location":"api/midgard-collections/#gnss_num2freq_i","text":"Full name: midgard.collections.enums.gnss_num2freq_I Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_I"},{"location":"api/midgard-collections/#gnss_num2freq_j","text":"Full name: midgard.collections.enums.gnss_num2freq_J Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_J"},{"location":"api/midgard-collections/#gnss_num2freq_r","text":"Full name: midgard.collections.enums.gnss_num2freq_R Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_R"},{"location":"api/midgard-collections/#gnss_num2freq_s","text":"Full name: midgard.collections.enums.gnss_num2freq_S Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) An enumeration.","title":"gnss_num2freq_S"},{"location":"api/midgard-collections/#has_value","text":"Full name: midgard.collections.enums.has_value Signature: (name: str, value: str) -> bool Check whether a named Enumeration defines a given value Args: name : Name used for Enumeration. value : Value of Enumeration. Returns: True if Enumeration defines value, False otherwise","title":"has_value()"},{"location":"api/midgard-collections/#log_color","text":"Full name: midgard.collections.enums.log_color Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Colors used when logging","title":"log_color"},{"location":"api/midgard-collections/#log_level","text":"Full name: midgard.collections.enums.log_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding how much log output to show","title":"log_level"},{"location":"api/midgard-collections/#register_enum","text":"Full name: midgard.collections.enums.register_enum Signature: (name: str) -> Callable[[enum.EnumMeta], enum.EnumMeta] Register a named Enumeration This allows for getting Enumerations with the get_enum-function. Args: name : Name used for Enumeration. Returns: Decorator that registers an Enumeration.","title":"register_enum()"},{"location":"api/midgard-collections/#write_level","text":"Full name: midgard.collections.enums.write_level Signature: (value, names=None, *, module=None, qualname=None, type=None, start=1) Levels used when deciding which fields of a dataset and other information to write to disk","title":"write_level"},{"location":"api/midgard-config/","text":"midgard.config midgard.config.config Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints: CasedConfigParser Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7fa99576b930>, converters=<object object at 0x7fa99576b930>) ConfigParser with case-sensitive keys Configuration Full name: midgard.config.config.Configuration Signature: (name: str) -> None Represents a Configuration ConfigurationEntry Full name: midgard.config.config.ConfigurationEntry Signature: (key: str, value: Any, *, source: str = '', meta: Union[Dict[str, str], NoneType] = None, vars_dict: Union[Dict[str, str], NoneType] = None, _used_as: Union[Set[str], NoneType] = None) -> None ConfigurationSection Full name: midgard.config.config.ConfigurationSection Signature: (name: str) -> None FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' midgard.config.files Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above. FileConfiguration Full name: midgard.config.files.FileConfiguration Signature: (name: str) -> None Configuration for handling files path_type (TypeVar) path_type = ~path_type","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfig","text":"","title":"midgard.config"},{"location":"api/midgard-config/#midgardconfigconfig","text":"Midgard library module for handling of configuration settings Description: A Configuration consists of one or several sections. Each ConfigurationSection consists of one or more entries. Each ConfigurationEntry consists of a key and a value. Examples: For basic use, an entry is looked up by simple attribute access. For instance if cfg is a Configuration with the section midgard which has an entry foo = bar : >>> cfg = Configuration(\"config_name\") >>> cfg.update(\"midgard\", \"foo\", \"bar\") >>> cfg.midgard.foo ConfigurationEntry(key='foo', value='bar') ConfigurationEntry has several access methods that convert the entry to a given data type: >>> cfg.update(\"midgard\", \"foo_pi\", 3.14, source=\"command line\") >>> cfg.midgard.foo_pi ConfigurationEntry(key='foo_pi', value='3.14') >>> cfg.midgard.foo_pi.float 3.14 >>> cfg.midgard.foo_pi.str '3.14' >>> cfg.midgard.foo_pi.tuple ('3.14',) Sources: Each configuration entry records its source. That is, where that entry was defined. Examples include read from file, set as a command line option, or programmatically from a dictionary. The source can be looked up on an individual entry, or for all entries in a configuration. >>> cfg.midgard.foo_pi.source 'command line' >>> cfg.sources # doctest: +SKIP {'/home/midgard/midgard.conf', 'command line'} Profiles: Fallback Configuration: Master Section: Replacement Variables: Help text and Type hints:","title":"midgard.config.config"},{"location":"api/midgard-config/#casedconfigparser","text":"Full name: midgard.config.config.CasedConfigParser Signature: (defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7fa99576b930>, converters=<object object at 0x7fa99576b930>) ConfigParser with case-sensitive keys","title":"CasedConfigParser"},{"location":"api/midgard-config/#configuration","text":"Full name: midgard.config.config.Configuration Signature: (name: str) -> None Represents a Configuration","title":"Configuration"},{"location":"api/midgard-config/#configurationentry","text":"Full name: midgard.config.config.ConfigurationEntry Signature: (key: str, value: Any, *, source: str = '', meta: Union[Dict[str, str], NoneType] = None, vars_dict: Union[Dict[str, str], NoneType] = None, _used_as: Union[Set[str], NoneType] = None) -> None","title":"ConfigurationEntry"},{"location":"api/midgard-config/#configurationsection","text":"Full name: midgard.config.config.ConfigurationSection Signature: (name: str) -> None","title":"ConfigurationSection"},{"location":"api/midgard-config/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-config/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-config/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-config/#midgardconfigfiles","text":"Midgard library module for opening files based on a special configuration Example: from midgard.config import files with files.open('eopc04_iau', mode='rt') as fid: for line in fid: print(line.strip()) Description: This module handles opening of files registered in a special configuration, typically a configuration file. The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to make sure files are properly closed they should normally be used with a context manager as in the example above.","title":"midgard.config.files"},{"location":"api/midgard-config/#fileconfiguration","text":"Full name: midgard.config.files.FileConfiguration Signature: (name: str) -> None Configuration for handling files","title":"FileConfiguration"},{"location":"api/midgard-config/#path_type-typevar","text":"path_type = ~path_type","title":"path_type (TypeVar)"},{"location":"api/midgard-data/","text":"midgard.data midgard.data._h5utils Simple utilities used by Dataset when dealing with HDF5 files decode_h5attr () Full name: midgard.data._h5utils.decode_h5attr Signature: (attr: Any) -> Any Convert hdf5 attribute back to its original datatype encode_h5attr () Full name: midgard.data._h5utils.encode_h5attr Signature: (data: Any) -> Any Convert a basic data type to something that can be saved as a hdf5 attribute midgard.data._position Module for dealing with positions, velocities and position corrections in different coordinate systems PosBase Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays PosVelArray Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PosVelDeltaArray Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. PositionArray Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function. PositionDeltaArray Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function. VelocityArray Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray VelocityDeltaArray Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray register_attribute () Full name: midgard.data._position.register_attribute Signature: (cls: Callable, name: str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Class to register the attribute for name : Name of attribute register_field () Full name: midgard.data._position.register_field Signature: (units: List[str], dependence: str = None) -> Callable Decorator used to register fields and their units Args: units: units for the field (tuple of strings) dependance: name of attribute that needs to be set for field to make sense register_system () Full name: midgard.data._position.register_system Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system. midgard.data._time Array with time epochs GpsTime Full name: midgard.data._time.GpsTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) GpsTimeDelta Full name: midgard.data._time.GpsTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TaiTime Full name: midgard.data._time.TaiTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TaiTimeDelta Full name: midgard.data._time.TaiTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TcgTime Full name: midgard.data._time.TcgTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TcgTimeDelta Full name: midgard.data._time.TcgTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TimeArray Full name: midgard.data._time.TimeArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time objects. Is immutable to allow the data to be hashable TimeBase Full name: midgard.data._time.TimeBase Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for TimeArray and TimeDeltaArray TimeDate Full name: midgard.data._time.TimeDate Signature: (val, val2=None, scale=None) TimeDateTime Full name: midgard.data._time.TimeDateTime Signature: (val, val2=None, scale=None) TimeDecimalYear Full name: midgard.data._time.TimeDecimalYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Variable year length. TimeDeltaArray Full name: midgard.data._time.TimeDeltaArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time delta objects. Is immutable to allow the data to be hashable TimeDeltaDateTime Full name: midgard.data._time.TimeDeltaDateTime Signature: (val, val2=None, scale=None) Time delta as datetime's timedelta TimeDeltaDay Full name: midgard.data._time.TimeDeltaDay Signature: (val, val2=None, scale=None) Time delta in days TimeDeltaFormat Full name: midgard.data._time.TimeDeltaFormat Signature: (val, val2=None, scale=None) Base class for Time Delta formats TimeDeltaJD Full name: midgard.data._time.TimeDeltaJD Signature: (val, val2=None, scale=None) Time delta as Julian days TimeDeltaSec Full name: midgard.data._time.TimeDeltaSec Signature: (val, val2=None, scale=None) Time delta in seconds TimeFormat Full name: midgard.data._time.TimeFormat Signature: (val, val2=None, scale=None) TimeGPSSec Full name: midgard.data._time.TimeGPSSec Signature: (val, val2=None, scale=None) Number of seconds since the GPS epoch 1980-01-06 00:00:00 UTC. TimeGPSWeekSec Full name: midgard.data._time.TimeGPSWeekSec Signature: (val, val2=None, scale=None) GPS weeks and seconds. TimeIso Full name: midgard.data._time.TimeIso Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DD HH:MM:SS.sss\u2026\u201d without the T TimeIsot Full name: midgard.data._time.TimeIsot Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DDTHH:MM:SS.sss\u2026\u201d TimeJD Full name: midgard.data._time.TimeJD Signature: (val, val2=None, scale=None) TimeJulianYear Full name: midgard.data._time.TimeJulianYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Fixed year length. TimeMJD Full name: midgard.data._time.TimeMJD Signature: (val, val2=None, scale=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000. TimePlotDate Full name: midgard.data._time.TimePlotDate Signature: (val, val2=None, scale=None) Matplotlib date format Matplotlib represents dates using floating point numbers specifying the number of days since 0001-01-01 UTC, plus 1. For example, 0001-01-01, 06:00 is 1.25, not 0.25. Values < 1, i.e. dates before 0001-01-01 UTC are not supported. Warning: This requires matplotlib version 3.2.2 or lower TimeStr Full name: midgard.data._time.TimeStr Signature: (val, val2=None, scale=None) Base class for text based time. TimeYearDoy Full name: midgard.data._time.TimeYearDoy Signature: (val, val2=None, scale=None) TimeYyDddSssss Full name: midgard.data._time.TimeYyDddSssss Signature: (val, val2=None, scale=None) Time as 2 digit year, doy and second of day. Text based format \"yy:ddd:sssss\" yy - decimal year without century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format TimeYyyyDddSssss Full name: midgard.data._time.TimeYyyyDddSssss Signature: (val, val2=None, scale=None) Time as 4-digit year, doy and second of day. Text based format \"yyyy:ddd:sssss\" yyyy - decimal year with century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format TtTime Full name: midgard.data._time.TtTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) TtTimeDelta Full name: midgard.data._time.TtTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) UtcTime Full name: midgard.data._time.UtcTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) UtcTimeDelta Full name: midgard.data._time.UtcTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) delta_gps_tai () Full name: midgard.data._time.delta_gps_tai Signature: (time: 'TimeArray') -> 'np_float' delta_tai_tt () Full name: midgard.data._time.delta_tai_tt Signature: (time: 'TimeArray') -> 'np_float' delta_tai_utc () Full name: midgard.data._time.delta_tai_utc Signature: (time: 'TimeArray') -> 'np_float' delta_tcg_tt () Full name: midgard.data._time.delta_tcg_tt Signature: (time: 'TimeArray') -> 'np_float' np_float (TypeVar) np_float = ~np_float read_tai_utc () Full name: midgard.data._time.read_tai_utc Signature: () register_format () Full name: midgard.data._time.register_format Signature: (cls: Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class. register_scale () Full name: midgard.data._time.register_scale Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale. midgard.data.collection A collection of fields Also serves as base class for dataset Collection Full name: midgard.data.collection.Collection Signature: () midgard.data.dataset A dataset for handling time series data Description: Dataset Full name: midgard.data.dataset.Dataset Signature: (num_obs: int = 0) -> None A dataset representing fields of data arrays Meta Full name: midgard.data.dataset.Meta Signature: (dict=None, /, **kwargs) field_type (str) field_type = 'time_delta' midgard.data.fieldtypes Field types that can be used by Dataset fieldtype () Full name: midgard.data.fieldtypes.fieldtype Signature: (data: Any) -> Callable Find correct field type for given data function () Full name: midgard.data.fieldtypes.function Signature: (plugin_name: str) -> Callable Function creating new field names () Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins midgard.data.fieldtypes._fieldtype Abstract class used to define different types of tables for a Dataset FieldType Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) Abstract class representing a type of field in the Dataset midgard.data.fieldtypes.bool A Dataset boolean field BoolField Full name: midgard.data.fieldtypes.bool.BoolField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.collection A Dataset collection field consisting of other fields CollectionField Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.float A Dataset float field FloatField Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.position A Dataset position field PositionField Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.position_delta A Dataset position delta field PositionDeltaField Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.posvel A Dataset position field PosVelField Full name: midgard.data.fieldtypes.posvel.PosVelField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.posvel_delta A Dataset position delta field PosVelDeltaField Full name: midgard.data.fieldtypes.posvel_delta.PosVelDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.sigma A Dataset sigma field SigmaField Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.text A Dataset text field TextField Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.time A Dataset time field TimeField Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.fieldtypes.time_delta A Dataset time field TimeDeltaField Full name: midgard.data.fieldtypes.time_delta.TimeDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) midgard.data.position Array with positions AcrPosVelDelta Full name: midgard.data.position.AcrPosVelDelta Signature: (val, ref_pos, **delta_args) AcrPositionDelta Full name: midgard.data.position.AcrPositionDelta Signature: (val, ref_pos, **delta_args) AcrVelocityDelta Full name: midgard.data.position.AcrVelocityDelta Signature: (val, ref_pos, **vel_args) EnuPosVelDelta Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args) EnuPositionDelta Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args) EnuVelocityDelta Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args) KeplerPosVel Full name: midgard.data.position.KeplerPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) LlhPosition Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) PosVel () Full name: midgard.data.position.PosVel Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. PosVelDelta () Full name: midgard.data.position.PosVelDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PosVelArray', **delta_args: Any) -> 'PosVelDeltaArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system. Position () Full name: midgard.data.position.Position Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. PositionDelta () Full name: midgard.data.position.PositionDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PositionArray', **delta_args: Any) -> 'PositionDeltaArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system. TrsPosVel Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPosVelDelta Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args) TrsPosition Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) TrsPositionDelta Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args) TrsVelocity Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args) TrsVelocityDelta Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args) is_position () Full name: midgard.data.position.is_position Signature: (val) is_position_delta () Full name: midgard.data.position.is_position_delta Signature: (val) is_posvel () Full name: midgard.data.position.is_posvel Signature: (val) is_posvel_delta () Full name: midgard.data.position.is_posvel_delta Signature: (val) midgard.data.sigma Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma. SigmaArray Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None, unit=None) midgard.data.time Array with time epochs Time () Full name: midgard.data.time.Time Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Union[numpy.ndarray, NoneType] = None, _jd1: Union[numpy.ndarray, NoneType] = None, _jd2: Union[numpy.ndarray, NoneType] = None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format TimeDelta () Full name: midgard.data.time.TimeDelta Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Union[numpy.ndarray, NoneType] = None) -> 'TimeDeltaArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format is_time () Full name: midgard.data.time.is_time Signature: (val) is_timedelta () Full name: midgard.data.time.is_timedelta Signature: (val)","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata","text":"","title":"midgard.data"},{"location":"api/midgard-data/#midgarddata_h5utils","text":"Simple utilities used by Dataset when dealing with HDF5 files","title":"midgard.data._h5utils"},{"location":"api/midgard-data/#decode_h5attr","text":"Full name: midgard.data._h5utils.decode_h5attr Signature: (attr: Any) -> Any Convert hdf5 attribute back to its original datatype","title":"decode_h5attr()"},{"location":"api/midgard-data/#encode_h5attr","text":"Full name: midgard.data._h5utils.encode_h5attr Signature: (data: Any) -> Any Convert a basic data type to something that can be saved as a hdf5 attribute","title":"encode_h5attr()"},{"location":"api/midgard-data/#midgarddata_position","text":"Module for dealing with positions, velocities and position corrections in different coordinate systems","title":"midgard.data._position"},{"location":"api/midgard-data/#posbase","text":"Full name: midgard.data._position.PosBase Signature: () Base class for the various position and velocity arrays","title":"PosBase"},{"location":"api/midgard-data/#posvelarray","text":"Full name: midgard.data._position.PosVelArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position and Velocity arrays This PosVelArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PosVelArray"},{"location":"api/midgard-data/#posveldeltaarray","text":"Full name: midgard.data._position.PosVelDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position and velocity deltas This PosVelDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PosVelDeltaArray"},{"location":"api/midgard-data/#positionarray","text":"Full name: midgard.data._position.PositionArray Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args) Base class for Position arrays This PositionArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the Position factory function.","title":"PositionArray"},{"location":"api/midgard-data/#positiondeltaarray","text":"Full name: midgard.data._position.PositionDeltaArray Signature: (val, ref_pos, **delta_args) Base class for position deltas This PositionDeltaArray should not be instantiated. Instead instantiate one of the system specific subclasses, typically using the PositionDelta factory function.","title":"PositionDeltaArray"},{"location":"api/midgard-data/#velocityarray","text":"Full name: midgard.data._position.VelocityArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityArray"},{"location":"api/midgard-data/#velocitydeltaarray","text":"Full name: midgard.data._position.VelocityDeltaArray Signature: (val, ref_pos, **vel_args) Base class for Velocity arrays This VelocityArray should not be instantiated. Instead instantiate one of the system specific subclasses. The intended usage will be through a PosVelArray","title":"VelocityDeltaArray"},{"location":"api/midgard-data/#register_attribute","text":"Full name: midgard.data._position.register_attribute Signature: (cls: Callable, name: str) -> None Function used to register new attributes on position arrays The registered attributes will be available as attributes on PositionArray and its subclasses. In addition, each attribute can be given as a parameter when creating a PositionArray. The reason for using this register-function instead of a regular attribute is to allow additional attributes to be added on all position systems. Args: cls : Class to register the attribute for name : Name of attribute","title":"register_attribute()"},{"location":"api/midgard-data/#register_field","text":"Full name: midgard.data._position.register_field Signature: (units: List[str], dependence: str = None) -> Callable Decorator used to register fields and their units Args: units: units for the field (tuple of strings) dependance: name of attribute that needs to be set for field to make sense","title":"register_field()"},{"location":"api/midgard-data/#register_system","text":"Full name: midgard.data._position.register_system Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new position systems The system name is read from the .system attribute of the Position class. Args: convert_to : Functions used to convert to other systems. convert_from : Functions used to convert from other systems. Returns: Decorator registering system.","title":"register_system()"},{"location":"api/midgard-data/#midgarddata_time","text":"Array with time epochs","title":"midgard.data._time"},{"location":"api/midgard-data/#gpstime","text":"Full name: midgard.data._time.GpsTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"GpsTime"},{"location":"api/midgard-data/#gpstimedelta","text":"Full name: midgard.data._time.GpsTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"GpsTimeDelta"},{"location":"api/midgard-data/#taitime","text":"Full name: midgard.data._time.TaiTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TaiTime"},{"location":"api/midgard-data/#taitimedelta","text":"Full name: midgard.data._time.TaiTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TaiTimeDelta"},{"location":"api/midgard-data/#tcgtime","text":"Full name: midgard.data._time.TcgTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TcgTime"},{"location":"api/midgard-data/#tcgtimedelta","text":"Full name: midgard.data._time.TcgTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TcgTimeDelta"},{"location":"api/midgard-data/#timearray","text":"Full name: midgard.data._time.TimeArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time objects. Is immutable to allow the data to be hashable","title":"TimeArray"},{"location":"api/midgard-data/#timebase","text":"Full name: midgard.data._time.TimeBase Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for TimeArray and TimeDeltaArray","title":"TimeBase"},{"location":"api/midgard-data/#timedate","text":"Full name: midgard.data._time.TimeDate Signature: (val, val2=None, scale=None)","title":"TimeDate"},{"location":"api/midgard-data/#timedatetime","text":"Full name: midgard.data._time.TimeDateTime Signature: (val, val2=None, scale=None)","title":"TimeDateTime"},{"location":"api/midgard-data/#timedecimalyear","text":"Full name: midgard.data._time.TimeDecimalYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Variable year length.","title":"TimeDecimalYear"},{"location":"api/midgard-data/#timedeltaarray","text":"Full name: midgard.data._time.TimeDeltaArray Signature: (val, fmt, val2=None, _jd1=None, _jd2=None) Base class for time delta objects. Is immutable to allow the data to be hashable","title":"TimeDeltaArray"},{"location":"api/midgard-data/#timedeltadatetime","text":"Full name: midgard.data._time.TimeDeltaDateTime Signature: (val, val2=None, scale=None) Time delta as datetime's timedelta","title":"TimeDeltaDateTime"},{"location":"api/midgard-data/#timedeltaday","text":"Full name: midgard.data._time.TimeDeltaDay Signature: (val, val2=None, scale=None) Time delta in days","title":"TimeDeltaDay"},{"location":"api/midgard-data/#timedeltaformat","text":"Full name: midgard.data._time.TimeDeltaFormat Signature: (val, val2=None, scale=None) Base class for Time Delta formats","title":"TimeDeltaFormat"},{"location":"api/midgard-data/#timedeltajd","text":"Full name: midgard.data._time.TimeDeltaJD Signature: (val, val2=None, scale=None) Time delta as Julian days","title":"TimeDeltaJD"},{"location":"api/midgard-data/#timedeltasec","text":"Full name: midgard.data._time.TimeDeltaSec Signature: (val, val2=None, scale=None) Time delta in seconds","title":"TimeDeltaSec"},{"location":"api/midgard-data/#timeformat","text":"Full name: midgard.data._time.TimeFormat Signature: (val, val2=None, scale=None)","title":"TimeFormat"},{"location":"api/midgard-data/#timegpssec","text":"Full name: midgard.data._time.TimeGPSSec Signature: (val, val2=None, scale=None) Number of seconds since the GPS epoch 1980-01-06 00:00:00 UTC.","title":"TimeGPSSec"},{"location":"api/midgard-data/#timegpsweeksec","text":"Full name: midgard.data._time.TimeGPSWeekSec Signature: (val, val2=None, scale=None) GPS weeks and seconds.","title":"TimeGPSWeekSec"},{"location":"api/midgard-data/#timeiso","text":"Full name: midgard.data._time.TimeIso Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DD HH:MM:SS.sss\u2026\u201d without the T","title":"TimeIso"},{"location":"api/midgard-data/#timeisot","text":"Full name: midgard.data._time.TimeIsot Signature: (val, val2=None, scale=None) ISO 8601 compliant date-time format \u201cYYYY-MM-DDTHH:MM:SS.sss\u2026\u201d","title":"TimeIsot"},{"location":"api/midgard-data/#timejd","text":"Full name: midgard.data._time.TimeJD Signature: (val, val2=None, scale=None)","title":"TimeJD"},{"location":"api/midgard-data/#timejulianyear","text":"Full name: midgard.data._time.TimeJulianYear Signature: (val, val2=None, scale=None) Time as year with decimal number. (Ex: 2000.0). Fixed year length.","title":"TimeJulianYear"},{"location":"api/midgard-data/#timemjd","text":"Full name: midgard.data._time.TimeMJD Signature: (val, val2=None, scale=None) Modified Julian Date time format. This represents the number of days since midnight on November 17, 1858. For example, 51544.0 in MJD is midnight on January 1, 2000.","title":"TimeMJD"},{"location":"api/midgard-data/#timeplotdate","text":"Full name: midgard.data._time.TimePlotDate Signature: (val, val2=None, scale=None) Matplotlib date format Matplotlib represents dates using floating point numbers specifying the number of days since 0001-01-01 UTC, plus 1. For example, 0001-01-01, 06:00 is 1.25, not 0.25. Values < 1, i.e. dates before 0001-01-01 UTC are not supported. Warning: This requires matplotlib version 3.2.2 or lower","title":"TimePlotDate"},{"location":"api/midgard-data/#timestr","text":"Full name: midgard.data._time.TimeStr Signature: (val, val2=None, scale=None) Base class for text based time.","title":"TimeStr"},{"location":"api/midgard-data/#timeyeardoy","text":"Full name: midgard.data._time.TimeYearDoy Signature: (val, val2=None, scale=None)","title":"TimeYearDoy"},{"location":"api/midgard-data/#timeyydddsssss","text":"Full name: midgard.data._time.TimeYyDddSssss Signature: (val, val2=None, scale=None) Time as 2 digit year, doy and second of day. Text based format \"yy:ddd:sssss\" yy - decimal year without century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format","title":"TimeYyDddSssss"},{"location":"api/midgard-data/#timeyyyydddsssss","text":"Full name: midgard.data._time.TimeYyyyDddSssss Signature: (val, val2=None, scale=None) Time as 4-digit year, doy and second of day. Text based format \"yyyy:ddd:sssss\" yyyy - decimal year with century ddd - zero padded decimal day of year sssss - zero padded seconds since midnight Note - Does not support leap seconds Returns: Time converted to yydddssss format","title":"TimeYyyyDddSssss"},{"location":"api/midgard-data/#tttime","text":"Full name: midgard.data._time.TtTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TtTime"},{"location":"api/midgard-data/#tttimedelta","text":"Full name: midgard.data._time.TtTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"TtTimeDelta"},{"location":"api/midgard-data/#utctime","text":"Full name: midgard.data._time.UtcTime Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"UtcTime"},{"location":"api/midgard-data/#utctimedelta","text":"Full name: midgard.data._time.UtcTimeDelta Signature: (val, fmt, val2=None, _jd1=None, _jd2=None)","title":"UtcTimeDelta"},{"location":"api/midgard-data/#delta_gps_tai","text":"Full name: midgard.data._time.delta_gps_tai Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_gps_tai()"},{"location":"api/midgard-data/#delta_tai_tt","text":"Full name: midgard.data._time.delta_tai_tt Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tai_tt()"},{"location":"api/midgard-data/#delta_tai_utc","text":"Full name: midgard.data._time.delta_tai_utc Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tai_utc()"},{"location":"api/midgard-data/#delta_tcg_tt","text":"Full name: midgard.data._time.delta_tcg_tt Signature: (time: 'TimeArray') -> 'np_float'","title":"delta_tcg_tt()"},{"location":"api/midgard-data/#np_float-typevar","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-data/#read_tai_utc","text":"Full name: midgard.data._time.read_tai_utc Signature: ()","title":"read_tai_utc()"},{"location":"api/midgard-data/#register_format","text":"Full name: midgard.data._time.register_format Signature: (cls: Callable) -> Callable Decorator used to register new time formats The format name is read from the .format attribute of the TimeFormat class.","title":"register_format()"},{"location":"api/midgard-data/#register_scale","text":"Full name: midgard.data._time.register_scale Signature: (convert_to: Dict[str, Callable] = None, convert_from: Dict[str, Callable] = None) -> Callable[[Callable], Callable] Decorator used to register new time scales The scale name is read from the .scale attribute of the Time class. Args: convert_to : Functions used to convert to other scales. convert_from : Functions used to convert from other scales. Returns: Decorator registering scale.","title":"register_scale()"},{"location":"api/midgard-data/#midgarddatacollection","text":"A collection of fields Also serves as base class for dataset","title":"midgard.data.collection"},{"location":"api/midgard-data/#collection","text":"Full name: midgard.data.collection.Collection Signature: ()","title":"Collection"},{"location":"api/midgard-data/#midgarddatadataset","text":"A dataset for handling time series data Description:","title":"midgard.data.dataset"},{"location":"api/midgard-data/#dataset","text":"Full name: midgard.data.dataset.Dataset Signature: (num_obs: int = 0) -> None A dataset representing fields of data arrays","title":"Dataset"},{"location":"api/midgard-data/#meta","text":"Full name: midgard.data.dataset.Meta Signature: (dict=None, /, **kwargs)","title":"Meta"},{"location":"api/midgard-data/#field_type-str","text":"field_type = 'time_delta'","title":"field_type (str)"},{"location":"api/midgard-data/#midgarddatafieldtypes","text":"Field types that can be used by Dataset","title":"midgard.data.fieldtypes"},{"location":"api/midgard-data/#fieldtype","text":"Full name: midgard.data.fieldtypes.fieldtype Signature: (data: Any) -> Callable Find correct field type for given data","title":"fieldtype()"},{"location":"api/midgard-data/#function","text":"Full name: midgard.data.fieldtypes.function Signature: (plugin_name: str) -> Callable Function creating new field","title":"function()"},{"location":"api/midgard-data/#names","text":"Full name: midgard.data.fieldtypes.names Signature: () -> List[str] Names of fieldtype plugins","title":"names()"},{"location":"api/midgard-data/#midgarddatafieldtypes_fieldtype","text":"Abstract class used to define different types of tables for a Dataset","title":"midgard.data.fieldtypes._fieldtype"},{"location":"api/midgard-data/#fieldtype_1","text":"Full name: midgard.data.fieldtypes._fieldtype.FieldType Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args) Abstract class representing a type of field in the Dataset","title":"FieldType"},{"location":"api/midgard-data/#midgarddatafieldtypesbool","text":"A Dataset boolean field","title":"midgard.data.fieldtypes.bool"},{"location":"api/midgard-data/#boolfield","text":"Full name: midgard.data.fieldtypes.bool.BoolField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"BoolField"},{"location":"api/midgard-data/#midgarddatafieldtypescollection","text":"A Dataset collection field consisting of other fields","title":"midgard.data.fieldtypes.collection"},{"location":"api/midgard-data/#collectionfield","text":"Full name: midgard.data.fieldtypes.collection.CollectionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"CollectionField"},{"location":"api/midgard-data/#midgarddatafieldtypesfloat","text":"A Dataset float field","title":"midgard.data.fieldtypes.float"},{"location":"api/midgard-data/#floatfield","text":"Full name: midgard.data.fieldtypes.float.FloatField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"FloatField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition","text":"A Dataset position field","title":"midgard.data.fieldtypes.position"},{"location":"api/midgard-data/#positionfield","text":"Full name: midgard.data.fieldtypes.position.PositionField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PositionField"},{"location":"api/midgard-data/#midgarddatafieldtypesposition_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.position_delta"},{"location":"api/midgard-data/#positiondeltafield","text":"Full name: midgard.data.fieldtypes.position_delta.PositionDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PositionDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel","text":"A Dataset position field","title":"midgard.data.fieldtypes.posvel"},{"location":"api/midgard-data/#posvelfield","text":"Full name: midgard.data.fieldtypes.posvel.PosVelField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PosVelField"},{"location":"api/midgard-data/#midgarddatafieldtypesposvel_delta","text":"A Dataset position delta field","title":"midgard.data.fieldtypes.posvel_delta"},{"location":"api/midgard-data/#posveldeltafield","text":"Full name: midgard.data.fieldtypes.posvel_delta.PosVelDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"PosVelDeltaField"},{"location":"api/midgard-data/#midgarddatafieldtypessigma","text":"A Dataset sigma field","title":"midgard.data.fieldtypes.sigma"},{"location":"api/midgard-data/#sigmafield","text":"Full name: midgard.data.fieldtypes.sigma.SigmaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"SigmaField"},{"location":"api/midgard-data/#midgarddatafieldtypestext","text":"A Dataset text field","title":"midgard.data.fieldtypes.text"},{"location":"api/midgard-data/#textfield","text":"Full name: midgard.data.fieldtypes.text.TextField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TextField"},{"location":"api/midgard-data/#midgarddatafieldtypestime","text":"A Dataset time field","title":"midgard.data.fieldtypes.time"},{"location":"api/midgard-data/#timefield","text":"Full name: midgard.data.fieldtypes.time.TimeField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TimeField"},{"location":"api/midgard-data/#midgarddatafieldtypestime_delta","text":"A Dataset time field","title":"midgard.data.fieldtypes.time_delta"},{"location":"api/midgard-data/#timedeltafield","text":"Full name: midgard.data.fieldtypes.time_delta.TimeDeltaField Signature: (num_obs, name, val=None, unit=None, write_level=None, multiplier=1, **field_args)","title":"TimeDeltaField"},{"location":"api/midgard-data/#midgarddataposition","text":"Array with positions","title":"midgard.data.position"},{"location":"api/midgard-data/#acrposveldelta","text":"Full name: midgard.data.position.AcrPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"AcrPosVelDelta"},{"location":"api/midgard-data/#acrpositiondelta","text":"Full name: midgard.data.position.AcrPositionDelta Signature: (val, ref_pos, **delta_args)","title":"AcrPositionDelta"},{"location":"api/midgard-data/#acrvelocitydelta","text":"Full name: midgard.data.position.AcrVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"AcrVelocityDelta"},{"location":"api/midgard-data/#enuposveldelta","text":"Full name: midgard.data.position.EnuPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPosVelDelta"},{"location":"api/midgard-data/#enupositiondelta","text":"Full name: midgard.data.position.EnuPositionDelta Signature: (val, ref_pos, **delta_args)","title":"EnuPositionDelta"},{"location":"api/midgard-data/#enuvelocitydelta","text":"Full name: midgard.data.position.EnuVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"EnuVelocityDelta"},{"location":"api/midgard-data/#keplerposvel","text":"Full name: midgard.data.position.KeplerPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"KeplerPosVel"},{"location":"api/midgard-data/#llhposition","text":"Full name: midgard.data.position.LlhPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"LlhPosition"},{"location":"api/midgard-data/#posvel","text":"Full name: midgard.data.position.PosVel Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PosVelArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVel()"},{"location":"api/midgard-data/#posveldelta","text":"Full name: midgard.data.position.PosVelDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PosVelArray', **delta_args: Any) -> 'PosVelDeltaArray' Factory for creating PosVelArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PosVelArray. Returns: Array with positions in the given system.","title":"PosVelDelta()"},{"location":"api/midgard-data/#position","text":"Full name: midgard.data.position.Position Signature: (val: numpy.ndarray, system: str, **pos_args: Any) -> 'PositionArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. pos_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"Position()"},{"location":"api/midgard-data/#positiondelta","text":"Full name: midgard.data.position.PositionDelta Signature: (val: numpy.ndarray, system: str, ref_pos: 'PositionArray', **delta_args: Any) -> 'PositionDeltaArray' Factory for creating PositionArrays for different systems See each position class for exact optional parameters. Args: val : Array of position values. system : Name of position system. ref_pos : Reference position. delta_args : Additional arguments used to create the PositionArray. Returns: Array with positions in the given system.","title":"PositionDelta()"},{"location":"api/midgard-data/#trsposvel","text":"Full name: midgard.data.position.TrsPosVel Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosVel"},{"location":"api/midgard-data/#trsposveldelta","text":"Full name: midgard.data.position.TrsPosVelDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPosVelDelta"},{"location":"api/midgard-data/#trsposition","text":"Full name: midgard.data.position.TrsPosition Signature: (val, ellipsoid=Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS'), **pos_args)","title":"TrsPosition"},{"location":"api/midgard-data/#trspositiondelta","text":"Full name: midgard.data.position.TrsPositionDelta Signature: (val, ref_pos, **delta_args)","title":"TrsPositionDelta"},{"location":"api/midgard-data/#trsvelocity","text":"Full name: midgard.data.position.TrsVelocity Signature: (val, ref_pos, **vel_args)","title":"TrsVelocity"},{"location":"api/midgard-data/#trsvelocitydelta","text":"Full name: midgard.data.position.TrsVelocityDelta Signature: (val, ref_pos, **vel_args)","title":"TrsVelocityDelta"},{"location":"api/midgard-data/#is_position","text":"Full name: midgard.data.position.is_position Signature: (val)","title":"is_position()"},{"location":"api/midgard-data/#is_position_delta","text":"Full name: midgard.data.position.is_position_delta Signature: (val)","title":"is_position_delta()"},{"location":"api/midgard-data/#is_posvel","text":"Full name: midgard.data.position.is_posvel Signature: (val)","title":"is_posvel()"},{"location":"api/midgard-data/#is_posvel_delta","text":"Full name: midgard.data.position.is_posvel_delta Signature: (val)","title":"is_posvel_delta()"},{"location":"api/midgard-data/#midgarddatasigma","text":"Array with sigma values See https://docs.scipy.org/doc/numpy/user/basics.subclassing.html for information about subclassing Numpy arrays. SigmaArray is a regular Numpy array with an added field, sigma.","title":"midgard.data.sigma"},{"location":"api/midgard-data/#sigmaarray","text":"Full name: midgard.data.sigma.SigmaArray Signature: (values, sigma=None, unit=None)","title":"SigmaArray"},{"location":"api/midgard-data/#midgarddatatime","text":"Array with time epochs","title":"midgard.data.time"},{"location":"api/midgard-data/#time","text":"Full name: midgard.data.time.Time Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Union[numpy.ndarray, NoneType] = None, _jd1: Union[numpy.ndarray, NoneType] = None, _jd2: Union[numpy.ndarray, NoneType] = None) -> 'TimeArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"Time()"},{"location":"api/midgard-data/#timedelta","text":"Full name: midgard.data.time.TimeDelta Signature: (val: numpy.ndarray, scale: str, fmt: str, val2: Union[numpy.ndarray, NoneType] = None) -> 'TimeDeltaArray' Factory for creating TimeArrays for different systems See each time class for exact optional parameters. Args: val : Array of time values. val2 : Optional second array for extra precision. scale : Name of time scale. fmt : Format of values given in val and val2. Returns: Array with epochs in the given time scale and format","title":"TimeDelta()"},{"location":"api/midgard-data/#is_time","text":"Full name: midgard.data.time.is_time Signature: (val)","title":"is_time()"},{"location":"api/midgard-data/#is_timedelta","text":"Full name: midgard.data.time.is_timedelta Signature: (val)","title":"is_timedelta()"},{"location":"api/midgard-dev/","text":"midgard.dev midgard.dev.console Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background! columns () Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters. dedent () Full name: midgard.dev.console.dedent Signature: (text: str, num_spaces: Union[int, NoneType] = None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string. fill () Full name: midgard.dev.console.fill Signature: (text: str, *, width: Union[int, NoneType] = None, hanging: Union[int, NoneType] = None, **tw_args: Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string. indent () Full name: midgard.dev.console.indent Signature: (text: str, num_spaces: int, **tw_args: Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string. lines () Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters. num_leading_spaces () Full name: midgard.dev.console.num_leading_spaces Signature: (text: str, space_char: str = ' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces. progress_bar () Full name: midgard.dev.console.progress_bar Signature: (iteration: int, total: int, prefix: str = '') Call in a loop to create terminal progress bar Args: iteration current iteration total total iterations prefix prefix string midgard.dev.exceptions Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling. FieldDoesNotExistError Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: () FieldExistsError Full name: midgard.dev.exceptions.FieldExistsError Signature: () InitializationError Full name: midgard.dev.exceptions.InitializationError Signature: () MidgardException Full name: midgard.dev.exceptions.MidgardException Signature: () MidgardExit Full name: midgard.dev.exceptions.MidgardExit Signature: () MissingConfigurationError Full name: midgard.dev.exceptions.MissingConfigurationError Signature: () MissingDataError Full name: midgard.dev.exceptions.MissingDataError Signature: () MissingEntryError Full name: midgard.dev.exceptions.MissingEntryError Signature: () MissingSectionError Full name: midgard.dev.exceptions.MissingSectionError Signature: () ParserError Full name: midgard.dev.exceptions.ParserError Signature: () TimerNotRunning Full name: midgard.dev.exceptions.TimerNotRunning Signature: () TimerRunning Full name: midgard.dev.exceptions.TimerRunning Signature: () UnitError Full name: midgard.dev.exceptions.UnitError Signature: () UnknownConstantError Full name: midgard.dev.exceptions.UnknownConstantError Signature: () UnknownConversionError Full name: midgard.dev.exceptions.UnknownConversionError Signature: () UnknownEnumError Full name: midgard.dev.exceptions.UnknownEnumError Signature: () UnknownPackageError Full name: midgard.dev.exceptions.UnknownPackageError Signature: () UnknownPluginError Full name: midgard.dev.exceptions.UnknownPluginError Signature: () UnknownSystemError Full name: midgard.dev.exceptions.UnknownSystemError Signature: () midgard.dev.library Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them. SimpleMock Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on). load_name () Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library. load_path () Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library. midgard.dev.log Midgard library module for logging Description: The Midgard log module provides simple logging functionality. To use it, you must first add a an active logger. This is typically done using the init-functions: init() and/or file_init() . init() initializes a console logger, where logging messages are written to the console. file_init() initializes a file logger, where logging messages are written to a defined file path. Following logging levels are defined: Level Description debug Debug messages info Information messages warn Warning messages error Error messages fatal Fatal error messages To write a log message, simply call log.{level} (e.g. log.info), whereby {level} is a placeholder for the defined logging levels in the table above. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix ConsoleLogger Full name: midgard.dev.log.ConsoleLogger Signature: (log_level: Union[str, NoneType] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters FileLogger Full name: midgard.dev.log.FileLogger Signature: (file_path: Union[str, pathlib.Path], log_level: Union[str, NoneType] = None, prefix: str = '', rotation: Union[int, NoneType] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones. Logger Full name: midgard.dev.log.Logger Signature: (log_level: Union[str, NoneType] = None, prefix: str = '') Abstract class that can be specialized to create new loggers all () Full name: midgard.dev.log.all Signature: (log_text: str, *, level: str = 'all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. blank () Full name: midgard.dev.log.blank Signature: () -> None Log blank line debug () Full name: midgard.dev.log.debug Signature: (log_text: str, *, level: str = 'debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. error () Full name: midgard.dev.log.error Signature: (log_text: str, *, level: str = 'error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. fatal () Full name: midgard.dev.log.fatal Signature: (log_text: str, *, level: str = 'fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. file_init Full name: midgard.dev.log.file_init Signature: (file_path: Union[str, pathlib.Path], log_level: Union[str, NoneType] = None, prefix: str = '', rotation: Union[int, NoneType] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones. info () Full name: midgard.dev.log.info Signature: (log_text: str, *, level: str = 'info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. init Full name: midgard.dev.log.init Signature: (log_level: Union[str, NoneType] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters log () Full name: midgard.dev.log.log Signature: (log_text: str, level: str) -> None Log text at the given level none () Full name: midgard.dev.log.none Signature: (log_text: str, *, level: str = 'none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. print_file () Full name: midgard.dev.log.print_file Signature: (log_path: Union[str, pathlib.Path], log_level: str = 'info', print_func: Callable[[str], NoneType] = <built-in function print>) -> None Print a log file with colors, stripping away any item below log_level warn () Full name: midgard.dev.log.warn Signature: (log_text: str, *, level: str = 'warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. midgard.dev.plugins Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(*args, **kwargs): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...) Plugin Full name: midgard.dev.plugins.Plugin Signature: (name: str, function: Callable, file_path: pathlib.Path, sort_value: int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called. add_alias () Full name: midgard.dev.plugins.add_alias Signature: (package_name: str, alias: str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory. call () Full name: midgard.dev.plugins.call Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, plugin_logger: Union[Callable[[str], NoneType], NoneType] = None, **plugin_args: Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in. call_all () Full name: midgard.dev.plugins.call_all Signature: (package_name: str, plugins: Union[List[str], NoneType] = None, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, plugin_logger: Union[Callable[[str], NoneType], NoneType] = None, **plugin_args: Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins. doc () Full name: midgard.dev.plugins.doc Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in. doc_all () Full name: midgard.dev.plugins.doc_all Signature: (package_name: str, plugins: Union[Iterable[str], NoneType] = None, prefix: Union[str, NoneType] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins. exists () Full name: midgard.dev.plugins.exists Signature: (package_name: str, plugin_name: str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise. get () Full name: midgard.dev.plugins.get Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in. load () Full name: midgard.dev.plugins.load Signature: (package_name: str, plugin_name: str, prefix: Union[str, NoneType] = None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix). names () Full name: midgard.dev.plugins.names Signature: (package_name: str, plugins: Union[Iterable[str], NoneType] = None, prefix: Union[str, NoneType] = None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins. parts () Full name: midgard.dev.plugins.parts Signature: (package_name: str, plugin_name: str, prefix: Union[str, NoneType] = None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts. register () Full name: midgard.dev.plugins.register Signature: (func: Callable, name: Union[str, NoneType] = None, sort_value: int = 0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered. register_named () Full name: midgard.dev.plugins.register_named Signature: (name: str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function. register_ordered () Full name: midgard.dev.plugins.register_ordered Signature: (sort_value: int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function. signature () Full name: midgard.dev.plugins.signature Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin midgard.dev.profiler Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler. CProfile Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program LineProfiler Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail Profiler Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers midgard.dev.timer Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details. AccumulatedTimer Full name: midgard.dev.timer.AccumulatedTimer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Union[Callable[[str], NoneType], NoneType] = functools.partial(<function log at 0x7fa9957b3dc0>, level='info')) -> None Timer Full name: midgard.dev.timer.Timer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Union[Callable[[str], NoneType], NoneType] = functools.partial(<function log at 0x7fa9957b3dc0>, level='info')) -> None Class for timing running time of functions and code blocks. midgard.dev.util Midgard library module with utility functions for easier script development Example: from midgard.dev import util directory, date = util.parse_args('string', 'date') Description: This module provides the boilerplate code necessary for starting a script. In particular handling of command line arguments and default options including --help are done. COMMAND (str) COMMAND = 'generate_api ' check_help_and_version () Full name: midgard.dev.util.check_help_and_version Signature: (module: str, doc_module: str = None, replace_vars: Dict[str, str] = {}) -> None Show help or version if asked for Show the help message parsed from the script's docstring if -h or --help option is given. Show the script's version if --version is given. Args: module : Module name. doc_module : Module containing help text. replace_vars : Dictionary with variable for replacement in docstring check_options () Full name: midgard.dev.util.check_options Signature: (*options: Tuple[str]) -> str Check if any of a list of options is specified on the command line Returns the actual option that is specified. The first option specified on the command line is returned if there are several matches. Returns the empty string if no option is specified. This means that this method works fine also in a boolean context, for example if check_options('-F', '--force'): do_something() Args: options : Strings specifying which options to check for, including '-'-prefix. Returns: String : Option that is specified, blank string if no option is specified get_callers () Full name: midgard.dev.util.get_callers Signature: () -> str Get a list of methods calling this function Returns: Lists all methods calling the function get_pid_and_server () Full name: midgard.dev.util.get_pid_and_server Signature: () -> str Find process id and name of server the analysis is running on Use the platform.uname to find servername instead of os.uname because the latter is not supported on Windows. Returns: Process id and name of server get_program_info () Full name: midgard.dev.util.get_program_info Signature: (module: str) -> str Get the name and the version of the running program Args: module : Module name. Returns: Program name and version get_program_name () Full name: midgard.dev.util.get_program_name Signature: () -> str Get the name of the running program Returns: String trying to be similar to how the user called the program. get_python_version () Full name: midgard.dev.util.get_python_version Signature: () -> str Find python version used Returns: Name of executable and version number no_traceback () Full name: midgard.dev.util.no_traceback Signature: (func) Decorator for turning off traceback, instead printing a simple error message Use the option --show_tb to show the traceback anyway. not_implemented () Full name: midgard.dev.util.not_implemented Signature: () -> None A placeholder for functions that are not implemented yet A note about the missing implementation is written to the log. options2args () Full name: midgard.dev.util.options2args Signature: (options: List[str]) -> Union[List[str], Dict[str, str]] Convert a list of command line options to a args and kwargs The options should be specified as a string with the necessary - or -- in front and options with a value should by separated by = (e.g. --station=stas). Args: options : List with options Returns: Tuple with non-keyword arguments and with keyword arguments parse_args () Full name: midgard.dev.util.parse_args Signature: (*param_types: Tuple[str], doc_module: str = None) -> Union[Any, List[Any]] Parse command line arguments and general options Parse arguments from the given parameter types. Args: param_types : Strings describing the expected parameter types. Each string must be one of the keys in #_PARSERS. doc_module : Module containing help text. Returns: List of command line arguments parsed according to param_types. read_option_value () Full name: midgard.dev.util.read_option_value Signature: (option: str, default: str = '') -> str Read the value of one command line option The option should be specified as a string with the necessary - or -- in front. If that option is not one of the command line arguments, default is returned. If there is a value following the option that value is returned as a string (separated by =). If there are several occurences of the option, the first one is returned. Args: option : Option specified with the leading - or --. default : Optional default value that is returned if the option is not specified. Returns: The option or the value of the option. The default value if the option is not specified. write_requirements () Full name: midgard.dev.util.write_requirements Signature: (file_path: Union[str, pathlib.Path]) -> None Write requirements (python modules) to file for reproducibility. Note that this only stores the modules that have been imported, and that have a __version__ -attribute (see PEP 396 - https://www.python.org/dev/peps/pep-0396/) Args: file_path : File path.","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddev","text":"","title":"midgard.dev"},{"location":"api/midgard-dev/#midgarddevconsole","text":"Simpler dealing with the console Description: Utilities for using the console. Mainly wrappers around other libraries to make them easier and more intuitive to use. Size of console: The two functions lines() and columns() report the current size of the console. Textwrapping: The function fill() can be used to rewrap a text-string so that it fits inside the console. Examples: >>> from midgard.dev import console >>> console.columns() # doctest: +SKIP 86 >>> print(console.fill(a_very_long_string)) # doctest: +SKIP Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras tempus eleifend feugiat. Maecenas vitae posuere metus. Sed sit amet fermentum velit. Aenean vitae turpis at risus sollicitudin fringilla in in nisi. Maecenas vitae ante libero. Aenean ut eros consequat, ornare erat at, tempus arcu. Suspendisse velit leo, eleifend eget mi non, vehicula ultricies erat. Vestibulum id nisi eget nisl venenatis dignissim. Duis cursus quam dui, vel hendrerit nibh lacinia id. >>> print(console.color.Fore.YELLOW + console.color.Back.BLUE + 'I am YELLOW text on BLUE backdrop!') # doctest: +SKIP I am YELLOW text on a BLUE background!","title":"midgard.dev.console"},{"location":"api/midgard-dev/#columns","text":"Full name: midgard.dev.console.columns Signature: () -> int The width of the console Returns: The width of the console in characters.","title":"columns()"},{"location":"api/midgard-dev/#dedent","text":"Full name: midgard.dev.console.dedent Signature: (text: str, num_spaces: Union[int, NoneType] = None) -> str Wrapper around textwrap.dedent Dedents at most num_spaces. If num_spaces is not specified, dedents as much as possible. Args: text : Text that will be dedented. num_spaces : Number of spaces that will be used for dedentation. Returns: Dedented string.","title":"dedent()"},{"location":"api/midgard-dev/#fill","text":"Full name: midgard.dev.console.fill Signature: (text: str, *, width: Union[int, NoneType] = None, hanging: Union[int, NoneType] = None, **tw_args: Any) -> str Wrapper around textwrap.fill The tw_args are passed on to textwrap.fill. See textwrap.TextWrapper for available keyword arguments. The default value for width is console.columns(), while the new argument hanging , if defined, will try to set (although not override) the textwrap-arguments initial_indent and subsequent_indent to create a hanging indent (no indent on the first line) of hanging spaces. Args: text : Text that will be wrapped. width : The maximum width (in characters) of wrapped lines. hanging : Number of characters used for hanging indent. tw_args : Arguments passed on to textwrap.fill . Returns: Wrapped string.","title":"fill()"},{"location":"api/midgard-dev/#indent","text":"Full name: midgard.dev.console.indent Signature: (text: str, num_spaces: int, **tw_args: Any) -> str Wrapper around textwrap.indent The tw_args are passed on to textwrap.indent. Args: text : Text that will be indented. num_spaces : Number of spaces that will be used for indentation. Returns: Indented string.","title":"indent()"},{"location":"api/midgard-dev/#lines","text":"Full name: midgard.dev.console.lines Signature: () -> int The height of the console Returns: The heigth of the console in characters.","title":"lines()"},{"location":"api/midgard-dev/#num_leading_spaces","text":"Full name: midgard.dev.console.num_leading_spaces Signature: (text: str, space_char: str = ' ') -> int Count number of leading spaces in a string Args: text : String to count. space_char : Which characters count as spaces. Returns: Number of leading spaces.","title":"num_leading_spaces()"},{"location":"api/midgard-dev/#progress_bar","text":"Full name: midgard.dev.console.progress_bar Signature: (iteration: int, total: int, prefix: str = '') Call in a loop to create terminal progress bar Args: iteration current iteration total total iterations prefix prefix string","title":"progress_bar()"},{"location":"api/midgard-dev/#midgarddevexceptions","text":"Definition of Midgard-specific exceptions Description: Custom exceptions used by Midgard for more specific error messages and handling.","title":"midgard.dev.exceptions"},{"location":"api/midgard-dev/#fielddoesnotexisterror","text":"Full name: midgard.dev.exceptions.FieldDoesNotExistError Signature: ()","title":"FieldDoesNotExistError"},{"location":"api/midgard-dev/#fieldexistserror","text":"Full name: midgard.dev.exceptions.FieldExistsError Signature: ()","title":"FieldExistsError"},{"location":"api/midgard-dev/#initializationerror","text":"Full name: midgard.dev.exceptions.InitializationError Signature: ()","title":"InitializationError"},{"location":"api/midgard-dev/#midgardexception","text":"Full name: midgard.dev.exceptions.MidgardException Signature: ()","title":"MidgardException"},{"location":"api/midgard-dev/#midgardexit","text":"Full name: midgard.dev.exceptions.MidgardExit Signature: ()","title":"MidgardExit"},{"location":"api/midgard-dev/#missingconfigurationerror","text":"Full name: midgard.dev.exceptions.MissingConfigurationError Signature: ()","title":"MissingConfigurationError"},{"location":"api/midgard-dev/#missingdataerror","text":"Full name: midgard.dev.exceptions.MissingDataError Signature: ()","title":"MissingDataError"},{"location":"api/midgard-dev/#missingentryerror","text":"Full name: midgard.dev.exceptions.MissingEntryError Signature: ()","title":"MissingEntryError"},{"location":"api/midgard-dev/#missingsectionerror","text":"Full name: midgard.dev.exceptions.MissingSectionError Signature: ()","title":"MissingSectionError"},{"location":"api/midgard-dev/#parsererror","text":"Full name: midgard.dev.exceptions.ParserError Signature: ()","title":"ParserError"},{"location":"api/midgard-dev/#timernotrunning","text":"Full name: midgard.dev.exceptions.TimerNotRunning Signature: ()","title":"TimerNotRunning"},{"location":"api/midgard-dev/#timerrunning","text":"Full name: midgard.dev.exceptions.TimerRunning Signature: ()","title":"TimerRunning"},{"location":"api/midgard-dev/#uniterror","text":"Full name: midgard.dev.exceptions.UnitError Signature: ()","title":"UnitError"},{"location":"api/midgard-dev/#unknownconstanterror","text":"Full name: midgard.dev.exceptions.UnknownConstantError Signature: ()","title":"UnknownConstantError"},{"location":"api/midgard-dev/#unknownconversionerror","text":"Full name: midgard.dev.exceptions.UnknownConversionError Signature: ()","title":"UnknownConversionError"},{"location":"api/midgard-dev/#unknownenumerror","text":"Full name: midgard.dev.exceptions.UnknownEnumError Signature: ()","title":"UnknownEnumError"},{"location":"api/midgard-dev/#unknownpackageerror","text":"Full name: midgard.dev.exceptions.UnknownPackageError Signature: ()","title":"UnknownPackageError"},{"location":"api/midgard-dev/#unknownpluginerror","text":"Full name: midgard.dev.exceptions.UnknownPluginError Signature: ()","title":"UnknownPluginError"},{"location":"api/midgard-dev/#unknownsystemerror","text":"Full name: midgard.dev.exceptions.UnknownSystemError Signature: ()","title":"UnknownSystemError"},{"location":"api/midgard-dev/#midgarddevlibrary","text":"Python wrapper around C-libraries Description: Loads a C-library. If a library is missing, a mock library is returned. If this mock is used for anything, a warning will be printed. This is done to avoid dependencies to all the C/C++-libraries for Python programs only using some of them.","title":"midgard.dev.library"},{"location":"api/midgard-dev/#simplemock","text":"Full name: midgard.dev.library.SimpleMock Signature: (name, raise_error=True) Class that can stand in for any other object The SimpleMock is used to stand in for any library that can not be imported. The mock object simply returns itself whenever it is called, or any attributes are looked up on the object. This is done, to avoid ImportErrors when a library is imported, but never used (typically because a plugin is loaded but never called). Instead the ImportError is raised when the SimpleMock is used in any way. The ImportError will only be raised once for any SimpleMock-object (which is only important if the ImportError is caught and the program carries on).","title":"SimpleMock"},{"location":"api/midgard-dev/#load_name","text":"Full name: midgard.dev.library.load_name Signature: (library_name, func_specs=None, name_patterns=None) Load the given shared C-library See load_path for an explanation of the func_specs and name_patterns -arguments. Args: library_name (String): The name of the library. func_specs (Dict): Specification of types in lib (see load_path). name_patterns (List): Name mangling patterns (see load_path). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_name()"},{"location":"api/midgard-dev/#load_path","text":"Full name: midgard.dev.library.load_path Signature: (library_path, func_specs=None, name_patterns=None) Load the given shared C-library The optional func_specs-dictionary can be used to specify argument and return types of functions in the library (see the ctypes documentation for information about argtypes and restype). The dictionary should be on the form:: func_spec = {'func_1': dict(func_name='name_of_func_1_in_lib', argtypes=[ ... argtypes of func_1 ... ], restype=... restype of func_1 ...), 'func_2': ... } If the library is not found, a mock library is returned instead. The mock library will print a warning if it is used. For some libraries, name mangling is used and this might be different depending on operating system and how the library is compiled. For instance, in a Fortran library the function Test might be represented as __Test on a Windows system and test_ (with lower-case t ) on a Linux system. This can be handled by providing a list of possible patterns. The above example can be handled by:: name_patterns = ('__{func_name}', '{func_name_lower}_') In this case, each function in func_specs is looked up by testing each pattern in turn until a match is found. Args: library_path (String): The path to the library. func_specs (Dict): Specification of types in library (see above). name_patterns (List): Name mangling patterns (see above). Returns: ctypes.CDLL: Representation of the shared library.","title":"load_path()"},{"location":"api/midgard-dev/#midgarddevlog","text":"Midgard library module for logging Description: The Midgard log module provides simple logging functionality. To use it, you must first add a an active logger. This is typically done using the init-functions: init() and/or file_init() . init() initializes a console logger, where logging messages are written to the console. file_init() initializes a file logger, where logging messages are written to a defined file path. Following logging levels are defined: Level Description debug Debug messages info Information messages warn Warning messages error Error messages fatal Fatal error messages To write a log message, simply call log.{level} (e.g. log.info), whereby {level} is a placeholder for the defined logging levels in the table above. To add a different logger, you should subclass the Logger abstract class. Example: >>> from midgard.dev import log >>> log.init(\"info\", prefix=\"My prefix\") >>> n, m = 5, 3 >>> log.info(f\"Calculating the inverse of a {n:>2d}x{m:<2d} matrix\") INFO [My prefix] Calculating the inverse of a 5x3 matrix","title":"midgard.dev.log"},{"location":"api/midgard-dev/#consolelogger","text":"Full name: midgard.dev.log.ConsoleLogger Signature: (log_level: Union[str, NoneType] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters","title":"ConsoleLogger"},{"location":"api/midgard-dev/#filelogger","text":"Full name: midgard.dev.log.FileLogger Signature: (file_path: Union[str, pathlib.Path], log_level: Union[str, NoneType] = None, prefix: str = '', rotation: Union[int, NoneType] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones.","title":"FileLogger"},{"location":"api/midgard-dev/#logger","text":"Full name: midgard.dev.log.Logger Signature: (log_level: Union[str, NoneType] = None, prefix: str = '') Abstract class that can be specialized to create new loggers","title":"Logger"},{"location":"api/midgard-dev/#all","text":"Full name: midgard.dev.log.all Signature: (log_text: str, *, level: str = 'all') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"all()"},{"location":"api/midgard-dev/#blank","text":"Full name: midgard.dev.log.blank Signature: () -> None Log blank line","title":"blank()"},{"location":"api/midgard-dev/#debug","text":"Full name: midgard.dev.log.debug Signature: (log_text: str, *, level: str = 'debug') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"debug()"},{"location":"api/midgard-dev/#error","text":"Full name: midgard.dev.log.error Signature: (log_text: str, *, level: str = 'error') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"error()"},{"location":"api/midgard-dev/#fatal","text":"Full name: midgard.dev.log.fatal Signature: (log_text: str, *, level: str = 'fatal') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"fatal()"},{"location":"api/midgard-dev/#file_init","text":"Full name: midgard.dev.log.file_init Signature: (file_path: Union[str, pathlib.Path], log_level: Union[str, NoneType] = None, prefix: str = '', rotation: Union[int, NoneType] = None) -> None Log to a file, the log files can be rotated so that older files are kept Args: file_path : File path. log_level : Define level from which logging should be started. prefix : Add prefix to logging messages. rotation : Logging files are rolled based on given number of rotations. That means, if there are old log files, they will be moved to files with extension .0, .1 and so on. If the argument is not specified, then existing logging file is overwritten from newer ones.","title":"file_init"},{"location":"api/midgard-dev/#info","text":"Full name: midgard.dev.log.info Signature: (log_text: str, *, level: str = 'info') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"info()"},{"location":"api/midgard-dev/#init","text":"Full name: midgard.dev.log.init Signature: (log_level: Union[str, NoneType] = None, prefix: str = '', use_command_line: bool = True) -> None Log to the console, the log level can also be set using command line parameters","title":"init"},{"location":"api/midgard-dev/#log","text":"Full name: midgard.dev.log.log Signature: (log_text: str, level: str) -> None Log text at the given level","title":"log()"},{"location":"api/midgard-dev/#none","text":"Full name: midgard.dev.log.none Signature: (log_text: str, *, level: str = 'none') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"none()"},{"location":"api/midgard-dev/#print_file","text":"Full name: midgard.dev.log.print_file Signature: (log_path: Union[str, pathlib.Path], log_level: str = 'info', print_func: Callable[[str], NoneType] = <built-in function print>) -> None Print a log file with colors, stripping away any item below log_level","title":"print_file()"},{"location":"api/midgard-dev/#warn","text":"Full name: midgard.dev.log.warn Signature: (log_text: str, *, level: str = 'warn') -> None partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"warn()"},{"location":"api/midgard-dev/#midgarddevplugins","text":"Set up a plug-in architecture for Midgard Description: In order to be able to add models, parsers, data sources etc without needing to hardcode names, but rather pick them from configuration files, we use a simple plug-in architecture. The plug-in mechanism is based on the different plug-ins registering themselves using the register decorator: from midgard.dev import plugins @plugins.register def simple_model(*args, **kwargs): ... Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. To list all plug-ins in a package use names : > from midgard.dev import plugins > plugins.names('midgard.models') ['model_one', 'model_three', 'model_two'] If the optional parameter config_key is given, then only plug-ins listed in the corresponding section in the current configuration file is listed. For instance, if the configuration file contains a line saying ham_models = model_three, model_one then we can list only the ham_models as follows: > from midgard.dev import plugins > plugins.names('midgard.models', config_key='ham_models') ['model_one', 'model_three'] Note that the plug-ins by default are sorted alphabetically. To run the plug-ins, use either call_all or call_one . The former calls all plug-ins and returns a dictionary containing the result from each plug-in. As with names the optional parameter config_key may be given: > from midgard.dev import plugins > plugins.call_all('midgard.models', config_key='ham_models', arg_to_plugin='hello') {'model_three': <result from model_three>, 'model_one': <result from model_one>} Arguments to the plug-ins should be passed as named arguments to call_all . Similarly, one plug-in may be called explicitly using call_one : > from midgard.dev import plugins > plugins.call_one('midgard.models', plugin_name='model_one', arg_to_plugin='hello') <result from model_one> There may be more than one function in each plug-in that is decorated by register . In this case, the default behaviour is that only the first function will be called. To call the other registered functions one should use the list_parts function to get a list of these functions and call them explicitly using the part optional parameter to call_one : > from midgard.dev import plugins > plugins.list_parts('midgard.techniques', plugin_name='vlbi') ['read', 'edit', 'calculate', 'estimate', 'write_result']) > for part in plugins.list_parts('midgard.techniques', plugin_name='vlbi'): ... plugins.call_one('midgard.techniques', plugin_name='vlbi', part=part, ...)","title":"midgard.dev.plugins"},{"location":"api/midgard-dev/#plugin","text":"Full name: midgard.dev.plugins.Plugin Signature: (name: str, function: Callable, file_path: pathlib.Path, sort_value: int) Information about a plug-in Args: name : Name of the plug-in. function : The plug-in. file_path : Path to the source code of the plug-in, may be used to add the source as a dependency. sort_value : Value used when sorting plug-ins in order to control the order they are called.","title":"Plugin"},{"location":"api/midgard-dev/#add_alias","text":"Full name: midgard.dev.plugins.add_alias Signature: (package_name: str, alias: str) -> None Add alias to plug-in package This allows one package of plug-ins to be spread over several directories Args: package_name : Name of package containing plug-ins. directory : Additional plug-in directory.","title":"add_alias()"},{"location":"api/midgard-dev/#call","text":"Full name: midgard.dev.plugins.call Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, plugin_logger: Union[Callable[[str], NoneType], NoneType] = None, **plugin_args: Any) -> Any Call one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to the plug-in. Returns: Return value of the plug-in.","title":"call()"},{"location":"api/midgard-dev/#call_all","text":"Full name: midgard.dev.plugins.call_all Signature: (package_name: str, plugins: Union[List[str], NoneType] = None, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, plugin_logger: Union[Callable[[str], NoneType], NoneType] = None, **plugin_args: Any) -> Dict[str, Any] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list or in the config file does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-in names that should be used (optional). part : Name of function to call within the plug-ins (optional). prefix : Prefix of the plug-in names, used for a plug-in if it is not found (optional). plugin_logger : Function used for logging (optional). plugin_args : Named arguments passed on to all the plug-ins. Returns: Dictionary of all results from the plug-ins.","title":"call_all()"},{"location":"api/midgard-dev/#doc","text":"Full name: midgard.dev.plugins.doc Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> str Document one plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Documentation of the plug-in.","title":"doc()"},{"location":"api/midgard-dev/#doc_all","text":"Full name: midgard.dev.plugins.doc_all Signature: (package_name: str, plugins: Union[Iterable[str], NoneType] = None, prefix: Union[str, NoneType] = None, long_doc: bool = True, include_details: bool = False, use_module: bool = False) -> Dict[str, str] Call all plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be called. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-ins are unknown (optional). long_doc : Whether to return the long doc-string or the short one-line string (optional). include_details : Whether to include development details like parameters and return values (optional). use_module : Whether to use module doc-string instead of plug-in doc-string (optional). Returns: Dictionary of all doc-strings from the plug-ins.","title":"doc_all()"},{"location":"api/midgard-dev/#exists","text":"Full name: midgard.dev.plugins.exists Signature: (package_name: str, plugin_name: str) -> bool Check whether or not a plug-in exists in a package Tries to import the given plug-in. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). Returns: True if plug-in exists, False otherwise.","title":"exists()"},{"location":"api/midgard-dev/#get","text":"Full name: midgard.dev.plugins.get Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None) -> midgard.dev.plugins.Plugin Get a specific plugin-object If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be called. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is not found (optional). Returns: Plugin-namedtuple representing the plug-in.","title":"get()"},{"location":"api/midgard-dev/#load","text":"Full name: midgard.dev.plugins.load Signature: (package_name: str, plugin_name: str, prefix: Union[str, NoneType] = None) -> str Load one plug-in from a package First tries to load the plugin with the given name. If that fails, it tries to load {prefix}_{plugin_name} instead. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in (module). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Actual name of plug-in (with or without prefix).","title":"load()"},{"location":"api/midgard-dev/#names","text":"Full name: midgard.dev.plugins.names Signature: (package_name: str, plugins: Union[Iterable[str], NoneType] = None, prefix: Union[str, NoneType] = None) -> List[str] List plug-ins in a package If plugins is given, it should be a list of names of plug-ins. If a plug-in listed in the plugins -list does not exist, an UnknownPluginError is raised. If plugins is not given, all available plugins will be listed. Do note, however, that this will import all python files in the package. Args: package_name : Name of package containing plug-ins. plugins : List of plug-ins that should be used (optional). prefix : Prefix of the plug-in names, used if any of the plug-in names are unknown (optional). Returns: List of strings with names of plug-ins.","title":"names()"},{"location":"api/midgard-dev/#parts","text":"Full name: midgard.dev.plugins.parts Signature: (package_name: str, plugin_name: str, prefix: Union[str, NoneType] = None) -> List[str] List all parts of one plug-in Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in. prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: List : Strings with names of parts.","title":"parts()"},{"location":"api/midgard-dev/#register","text":"Full name: midgard.dev.plugins.register Signature: (func: Callable, name: Union[str, NoneType] = None, sort_value: int = 0) -> Callable Decorator used to register a plug-in Plug-ins are registered based on the name of the module (file) they are defined in, as well as the package (directory) which contains them. Typically all plug-ins of a given type are collected in a package, e.g. models, techniques, parsers, etc. The path to the source code file is also stored. This is used to be able to add the source code as a dependency file when the plug-in is called. If name is given, the plug-in is registered based on this name instead of the name of the module. The name of the module is still registered as a part that can be used to distinguish between similar plug-ins in different files (see for instance how session is used in midgard.pipelines ). Args: func : The function that is being registered. name : Alternative name of plug-in. Used by register_named . sort_value : The value used when sorting plug-ins. Used by register_ordered . Returns: The function that is being registered.","title":"register()"},{"location":"api/midgard-dev/#register_named","text":"Full name: midgard.dev.plugins.register_named Signature: (name: str) -> Callable Decorator used to register a named plug-in This allows for overriding the name used to register the plug-in. See register for more details. Args: name : Name used for plug-in instead of module name. Returns: Decorator that registers a named function.","title":"register_named()"},{"location":"api/midgard-dev/#register_ordered","text":"Full name: midgard.dev.plugins.register_ordered Signature: (sort_value: int) -> Callable Decorator used to register a plug-in with a specific sort order The sort value should be a number. Lower numbers are sorted first, higher numbers last. Plug-ins without an explicit sort_order gets the sort value of 0. Args: sort_value : The value used when sorting plug-ins. Returns: Decorator that registers an ordered function.","title":"register_ordered()"},{"location":"api/midgard-dev/#signature","text":"Full name: midgard.dev.plugins.signature Signature: (package_name: str, plugin_name: str, part: Union[str, NoneType] = None, prefix: Union[str, NoneType] = None) -> inspect.Signature Get signature of a plug-in If the plug-in is not part of the package an UnknownPluginError is raised. If there are several functions registered in a plug-in and part is not specified, then the first function registered in the plug-in will be documented. Args: package_name : Name of package containing plug-ins. plugin_name : Name of the plug-in, i.e. the module containing the plug-in. part : Name of function to call within the plug-in (optional). prefix : Prefix of the plug-in name, used if the plug-in name is unknown (optional). Returns: Signature of the plugin","title":"signature()"},{"location":"api/midgard-dev/#midgarddevprofiler","text":"Add a profiler when running Supports several profilers including cprofile, line_profiler, memprof and memory_profiler.","title":"midgard.dev.profiler"},{"location":"api/midgard-dev/#cprofile","text":"Full name: midgard.dev.profiler.CProfile Signature: () cprofile is used for profiling the whole program","title":"CProfile"},{"location":"api/midgard-dev/#lineprofiler","text":"Full name: midgard.dev.profiler.LineProfiler Signature: () line_profiler is used to profile one or a few functions in detail","title":"LineProfiler"},{"location":"api/midgard-dev/#profiler","text":"Full name: midgard.dev.profiler.Profiler Signature: () Base class for profilers","title":"Profiler"},{"location":"api/midgard-dev/#midgarddevtimer","text":"Class for timing the running time of functions and code blocks Description: The dev.timer can be used to log the running time of functions and general code blocks. Typically, you will import the Timer -class from within the module: from midgard.dev.timer import Timer The Timer can then be used in three different ways: As a decorator to time one function: @Timer('The time to execute some_function was') def some_function(some_argument, some_other_argument=some_value): pass As a context manager together with with to time a code block: with Timer('Finish doing stuff in', logger=logger.debug) as t: do_something() do_something_else() With explicit start - and end -statements: t = Timer() t.start() do_something() do_something_else() t.end() As can be seen in the examples above, Timer() may be called with several optional parameters, including the text to report when the timer ends and which logger is used to report the timing. See Timer.__init__ for more details.","title":"midgard.dev.timer"},{"location":"api/midgard-dev/#accumulatedtimer","text":"Full name: midgard.dev.timer.AccumulatedTimer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Union[Callable[[str], NoneType], NoneType] = functools.partial(<function log at 0x7fa9957b3dc0>, level='info')) -> None","title":"AccumulatedTimer"},{"location":"api/midgard-dev/#timer","text":"Full name: midgard.dev.timer.Timer Signature: (text: str = 'Elapsed time:', fmt: str = '.4f', logger: Union[Callable[[str], NoneType], NoneType] = functools.partial(<function log at 0x7fa9957b3dc0>, level='info')) -> None Class for timing running time of functions and code blocks.","title":"Timer"},{"location":"api/midgard-dev/#midgarddevutil","text":"Midgard library module with utility functions for easier script development Example: from midgard.dev import util directory, date = util.parse_args('string', 'date') Description: This module provides the boilerplate code necessary for starting a script. In particular handling of command line arguments and default options including --help are done.","title":"midgard.dev.util"},{"location":"api/midgard-dev/#command-str","text":"COMMAND = 'generate_api '","title":"COMMAND (str)"},{"location":"api/midgard-dev/#check_help_and_version","text":"Full name: midgard.dev.util.check_help_and_version Signature: (module: str, doc_module: str = None, replace_vars: Dict[str, str] = {}) -> None Show help or version if asked for Show the help message parsed from the script's docstring if -h or --help option is given. Show the script's version if --version is given. Args: module : Module name. doc_module : Module containing help text. replace_vars : Dictionary with variable for replacement in docstring","title":"check_help_and_version()"},{"location":"api/midgard-dev/#check_options","text":"Full name: midgard.dev.util.check_options Signature: (*options: Tuple[str]) -> str Check if any of a list of options is specified on the command line Returns the actual option that is specified. The first option specified on the command line is returned if there are several matches. Returns the empty string if no option is specified. This means that this method works fine also in a boolean context, for example if check_options('-F', '--force'): do_something() Args: options : Strings specifying which options to check for, including '-'-prefix. Returns: String : Option that is specified, blank string if no option is specified","title":"check_options()"},{"location":"api/midgard-dev/#get_callers","text":"Full name: midgard.dev.util.get_callers Signature: () -> str Get a list of methods calling this function Returns: Lists all methods calling the function","title":"get_callers()"},{"location":"api/midgard-dev/#get_pid_and_server","text":"Full name: midgard.dev.util.get_pid_and_server Signature: () -> str Find process id and name of server the analysis is running on Use the platform.uname to find servername instead of os.uname because the latter is not supported on Windows. Returns: Process id and name of server","title":"get_pid_and_server()"},{"location":"api/midgard-dev/#get_program_info","text":"Full name: midgard.dev.util.get_program_info Signature: (module: str) -> str Get the name and the version of the running program Args: module : Module name. Returns: Program name and version","title":"get_program_info()"},{"location":"api/midgard-dev/#get_program_name","text":"Full name: midgard.dev.util.get_program_name Signature: () -> str Get the name of the running program Returns: String trying to be similar to how the user called the program.","title":"get_program_name()"},{"location":"api/midgard-dev/#get_python_version","text":"Full name: midgard.dev.util.get_python_version Signature: () -> str Find python version used Returns: Name of executable and version number","title":"get_python_version()"},{"location":"api/midgard-dev/#no_traceback","text":"Full name: midgard.dev.util.no_traceback Signature: (func) Decorator for turning off traceback, instead printing a simple error message Use the option --show_tb to show the traceback anyway.","title":"no_traceback()"},{"location":"api/midgard-dev/#not_implemented","text":"Full name: midgard.dev.util.not_implemented Signature: () -> None A placeholder for functions that are not implemented yet A note about the missing implementation is written to the log.","title":"not_implemented()"},{"location":"api/midgard-dev/#options2args","text":"Full name: midgard.dev.util.options2args Signature: (options: List[str]) -> Union[List[str], Dict[str, str]] Convert a list of command line options to a args and kwargs The options should be specified as a string with the necessary - or -- in front and options with a value should by separated by = (e.g. --station=stas). Args: options : List with options Returns: Tuple with non-keyword arguments and with keyword arguments","title":"options2args()"},{"location":"api/midgard-dev/#parse_args","text":"Full name: midgard.dev.util.parse_args Signature: (*param_types: Tuple[str], doc_module: str = None) -> Union[Any, List[Any]] Parse command line arguments and general options Parse arguments from the given parameter types. Args: param_types : Strings describing the expected parameter types. Each string must be one of the keys in #_PARSERS. doc_module : Module containing help text. Returns: List of command line arguments parsed according to param_types.","title":"parse_args()"},{"location":"api/midgard-dev/#read_option_value","text":"Full name: midgard.dev.util.read_option_value Signature: (option: str, default: str = '') -> str Read the value of one command line option The option should be specified as a string with the necessary - or -- in front. If that option is not one of the command line arguments, default is returned. If there is a value following the option that value is returned as a string (separated by =). If there are several occurences of the option, the first one is returned. Args: option : Option specified with the leading - or --. default : Optional default value that is returned if the option is not specified. Returns: The option or the value of the option. The default value if the option is not specified.","title":"read_option_value()"},{"location":"api/midgard-dev/#write_requirements","text":"Full name: midgard.dev.util.write_requirements Signature: (file_path: Union[str, pathlib.Path]) -> None Write requirements (python modules) to file for reproducibility. Note that this only stores the modules that have been imported, and that have a __version__ -attribute (see PEP 396 - https://www.python.org/dev/peps/pep-0396/) Args: file_path : File path.","title":"write_requirements()"},{"location":"api/midgard-files/","text":"midgard.files midgard.files.dates Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency. FMT_date (str) FMT_date = '%Y-%m-%d' FMT_datetime (str) FMT_datetime = '%Y-%m-%d %H:%M:%S' FMT_dt_file (str) FMT_dt_file = '%Y%m%d-%H%M%S' date_vars () Full name: midgard.files.dates.date_vars Signature: (date: Union[datetime.date, datetime.datetime, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date. midgard.files.dependencies Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed. add () Full name: midgard.files.dependencies.add Signature: (*file_paths: Union[str, pathlib.Path], label: str = '') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies. changed () Full name: midgard.files.dependencies.changed Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise. get_md5 () Full name: midgard.files.dependencies.get_md5 Signature: (file_path: Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file. get_paths_with_label () Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path: Union[str, pathlib.Path], label_pattern: str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths. get_timestamp () Full name: midgard.files.dependencies.get_timestamp Signature: (file_path: Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file. init () Full name: midgard.files.dependencies.init Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. write () Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file midgard.files.files Utilities for working with files move () Full name: midgard.files.files.move Signature: (from_path: Union[str, pathlib.Path], to_path: Union[str, pathlib.Path], overwrite: bool = True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten. open () Full name: midgard.files.files.open Signature: (file_path: Union[str, pathlib.Path], create_dirs: bool = False, open_as_gzip: Union[bool, NoneType] = None, **open_args: Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file. midgard.files.url Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment. URL Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"midgard.files"},{"location":"api/midgard-files/#midgardfiles","text":"","title":"midgard.files"},{"location":"api/midgard-files/#midgardfilesdates","text":"Convenience functions for working with dates Description: Formats and converters that can be used for convenience and consistency.","title":"midgard.files.dates"},{"location":"api/midgard-files/#fmt_date-str","text":"FMT_date = '%Y-%m-%d'","title":"FMT_date (str)"},{"location":"api/midgard-files/#fmt_datetime-str","text":"FMT_datetime = '%Y-%m-%d %H:%M:%S'","title":"FMT_datetime (str)"},{"location":"api/midgard-files/#fmt_dt_file-str","text":"FMT_dt_file = '%Y%m%d-%H%M%S'","title":"FMT_dt_file (str)"},{"location":"api/midgard-files/#date_vars","text":"Full name: midgard.files.dates.date_vars Signature: (date: Union[datetime.date, datetime.datetime, NoneType]) -> Dict[str, str] Construct a dict of date variables From a given date, construct a dict containing all relevant date variables. This dict can be used to for instance replace variables in file names. Examples: >>> from datetime import date >>> date_vars(date(2009, 11, 2)) # doctest: +NORMALIZE_WHITESPACE {'yyyy': '2009', 'ce': '20', 'yy': '09', 'm': '11', 'mm': '11', 'mmm': 'nov', 'MMM': 'NOV', 'd': '2', 'dd': '02', 'doy': '306', 'dow': '1', 'h': '0', 'hh': '00'} >>> date_vars(None) {} Args: date : The given date. Returns: Dictionary with date variables for the given date.","title":"date_vars()"},{"location":"api/midgard-files/#midgardfilesdependencies","text":"Midgard library module for handling dependencies Description: Stores a list of files with a hash/checksum or a timestamp that can be used to detect if a file changes. Two strategies are available: Timestamps: Fast, but not always reliable as timestamps may update without the file actually changing. md5 hash/checksum: Slower, since it needs to read through the whole file, but will reliably only trigger when a file has changed.","title":"midgard.files.dependencies"},{"location":"api/midgard-files/#add","text":"Full name: midgard.files.dependencies.add Signature: (*file_paths: Union[str, pathlib.Path], label: str = '') -> None Add a list of files to the list of dependencies Records the current time stamp or md5 hash of the files specified by file paths, and stores as dependencies on the dependency file. Before adding dependencies, a call to init() has to be done, to set up where to store the dependencies. Args: file_paths : List of file paths to add to the dependency file. label : Optional label for dependencies.","title":"add()"},{"location":"api/midgard-files/#changed","text":"Full name: midgard.files.dependencies.changed Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> bool Check if the dependencies have changed Returns True if any of the files listed in the dependency file have changed, or if the dependency file itself does not exist. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums. Returns: True if any file has changed or if the dependecy file does not exist, False otherwise.","title":"changed()"},{"location":"api/midgard-files/#get_md5","text":"Full name: midgard.files.dependencies.get_md5 Signature: (file_path: Union[str, pathlib.Path]) -> str Return a md5 checksum based on a file. Args: file_path : Path to file. Returns: Hex-string representing the contents of the file.","title":"get_md5()"},{"location":"api/midgard-files/#get_paths_with_label","text":"Full name: midgard.files.dependencies.get_paths_with_label Signature: (file_path: Union[str, pathlib.Path], label_pattern: str) -> List[pathlib.Path] Find all paths with the given label Args: file_path : Path to dependency file. label_pattern : String with label or regular expression (e.g. 'gnss_rinex_nav_[MGE]' or 'gnss_rinex_nav_.'). Returns: List : List of file paths.","title":"get_paths_with_label()"},{"location":"api/midgard-files/#get_timestamp","text":"Full name: midgard.files.dependencies.get_timestamp Signature: (file_path: Union[str, pathlib.Path]) -> str Return a textual timestamp from the modification date of a file Args: file_path : Path to file. Returns: String representing the modification date of the file.","title":"get_timestamp()"},{"location":"api/midgard-files/#init","text":"Full name: midgard.files.dependencies.init Signature: (file_path: Union[str, pathlib.Path], fast_check: bool = True) -> None Start a clean list of dependencies The file_path is to the file in which dependencies are stored. This is cached, so after init() is run, the other functions do not need to specify the file_path. Args: file_path : Path to dependency file. fast_check : Fast check uses timestamps, slow check uses md5 checksums.","title":"init()"},{"location":"api/midgard-files/#write","text":"Full name: midgard.files.dependencies.write Signature: () -> None Write dependencies to file","title":"write()"},{"location":"api/midgard-files/#midgardfilesfiles","text":"Utilities for working with files","title":"midgard.files.files"},{"location":"api/midgard-files/#move","text":"Full name: midgard.files.files.move Signature: (from_path: Union[str, pathlib.Path], to_path: Union[str, pathlib.Path], overwrite: bool = True) -> None Move a file to another path With overwrite set to True, to_path may already exist and will be overwritten without warning. Setting overwrite to False will raise a FileExistsError if to_path already exists. Args: from_path : Path of file to be moved. to_path : Path file will be moved to. overwrite : If True, to_path may already exist. If False, to_path will never be overwritten.","title":"move()"},{"location":"api/midgard-files/#open","text":"Full name: midgard.files.files.open Signature: (file_path: Union[str, pathlib.Path], create_dirs: bool = False, open_as_gzip: Union[bool, NoneType] = None, **open_args: Any) -> Iterator Open a file. Can automatically create the necessary directories before writing to a file, as well as handle gzipped files. With open_as_gzip set to None (default), it will try to detect whether the path is a .gz file simply by looking at the path suffix. For more control, you can set the parameter to True or False explicitly. Args: file_path : String or pathlib.Path representing the full file path. create_dirs : True or False, if True missing directories are created. open_as_gzip : Use gzip library to open file. open_args : All keyword arguments are passed on to the built-in open. Returns: File object representing the file.","title":"open()"},{"location":"api/midgard-files/#midgardfilesurl","text":"Midgard library module, defining a URL class that mirrors Pathlib.Path Warning: There are many intricacies of URLs that are not handled by this class at the moment.","title":"midgard.files.url"},{"location":"api/midgard-files/#url","text":"Full name: midgard.files.url.URL Signature: () Simple wrapper around String to have URLs work similar to pathlib.Path","title":"URL"},{"location":"api/midgard-gnss/","text":"midgard.gnss midgard.gnss.compute_dops Compute DOP (dilution of precision) Description: Calculate GDOP, PDOP, TDOP, HDOP and VDOP based on elevation and azimuth between station and satellite for each observation epoch. compute_dops () Full name: midgard.gnss.compute_dops.compute_dops Signature: (az: numpy.ndarray, el: numpy.ndarray) -> Tuple[numpy.ndarray, ...] Compute dilution of precision (DOP) for an observation epoch It should be noted, that the weight of observations is not considered. The observation weight matrix is assumed to be an identity matrix. The cofactor matrix Q is related to a topocentric coordinate system (north, east, up): | q_nn q_ne q_nu q_nt | Q = | q_ne q_ee q_eu q_et | | q_nu q_eu q_nn q_nt | | q_nt q_et q_nt q_tt | Reference: Banerjee, P. and Bose, A. (1996): \"Evaluation of GPS PDOP from elevation and azimuth of satellites\", Indian Journal of Radio & Space Physics, Vol. 25, April 1996, pp. 110-113 Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) Returns: Tuple with GDOP, PDOP, TDOP, HDOP and VDOP midgard.gnss.gnss Midgard library module including functions for GNSS modeling Example: from migard.gnss import gnss Description: This module will provide functions for GNSS modeling. get_number_of_satellites () Full name: midgard.gnss.gnss.get_number_of_satellites Signature: (systems: numpy.ndarray, satellites: numpy.ndarray, epochs: numpy.ndarray) -> numpy.ndarray Get number of satellites per epoch Args: satellites : Array with satellite PRN number together with GNSS identifier (e.g. G07) systems : Array with GNSS identifiers (e.g. G, E, R, ...) epochs : Array with observation epochs (e.g. as datetime objects) Returns: Number of satellites per epoch get_rinex_file_version () Full name: midgard.gnss.gnss.get_rinex_file_version Signature: (file_path: pathlib.PosixPath) -> str Get RINEX file version for a given file path Args: file_path : File path. Returns: RINEX file version obstype_to_freq () Full name: midgard.gnss.gnss.obstype_to_freq Signature: (sys: str, obstype: str) -> float Get GNSS frequency based on given GNSS observation type Args: sys : GNSS identifier (e.g. 'E', 'G', ...) obstype : Observation type (e.g. 'L1', 'P1', 'C1X', ...) Return: GNSS frequency in [Hz] midgard.gnss.rec_velocity_est E_OMGA (float) E_OMGA = 7.2921151467e-05 epilog (str) epilog = '\\n**EXAMPLE**\\n rec_velocity_est.py \\n args:\\n NONE\\n \\n**COPYRIGHT**\\n | Copyright 2019, by the Geodetic Institute, NMA\\n | All rights reserved\\n\\n**AUTHORS**\\n | Mohammed Ouassou \\n | Geodetic Institute, NMA\\n | Kartverksveien 21, N-3511\\n | H\u00f8nefoss, Norway\\n \\n' lambda_E1 (float) lambda_E1 = 0.19029367279836487 prolog (str) prolog = '\\n**PROGRAM**\\n rec_velocity_est.py\\n \\n**PURPOSE**\\n \"GNSS Receiver velocity estimation by Doppler measurements\\n \\n Doppler shift, affecting the frequency of the signal received from a GNSS satellite, is related to the user-satellite relative motion \\n and is useful to study the receiver motion. Using measurements from at least four simultaneous Doppler measurements, Least Square (LS) \\n or Kalman filter (KF) estimation techniques can be employed to obtain an estimate of the four unknown dx=(Vx, Vy, Vz, rate(cdt) ).\\n \\n FACTS:\\n F.1 The design matrix H of the Doppler based velocity model is the same as the pseudorange case. Constellation geometry influences the \\n velocity accuracy according to DOP.\\n F.2 The measurement errors is composed of systematic errors (orbital errors, atmosphere, and so forth) and the measurement noise. \\n Noting that the Doppler is the time derivative of the carrier phase, the systematic Doppler errors are the time derivative of the \\n carrier phase errors and changing slowly with time. The magnitude is at the level of millimeters per seconds. \\n F.3 Geometry factors influences the estimation process. \\n F.4 The implementation is based on the paper of Mark Petovello (GNSS solutions).\\n \\n VALIDATION:\\n V.1 CNES software package SPRING is used to validate the implemented SPV.\\n V.2 Solution validation is based on Chi-square test and GDOP values on epoch-by-epoch basis\\n \\n**USAGE**\\n' spvDoppler Full name: midgard.gnss.rec_velocity_est.spvDoppler Signature: (z, H, x, dx, Qx) midgard.gnss.solution_validation comp_quality_indicators () Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat: numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE epilog (str) epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n' get_my_parser () Full name: midgard.gnss.solution_validation.get_my_parser Signature: () main () Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation TODO: This should be done via midgard/tests/gnss !!! prolog (str) prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n' sol_validation () Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals: numpy.ndarray, alpha_siglev: float, n_params: int = 4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnss","text":"","title":"midgard.gnss"},{"location":"api/midgard-gnss/#midgardgnsscompute_dops","text":"Compute DOP (dilution of precision) Description: Calculate GDOP, PDOP, TDOP, HDOP and VDOP based on elevation and azimuth between station and satellite for each observation epoch.","title":"midgard.gnss.compute_dops"},{"location":"api/midgard-gnss/#compute_dops","text":"Full name: midgard.gnss.compute_dops.compute_dops Signature: (az: numpy.ndarray, el: numpy.ndarray) -> Tuple[numpy.ndarray, ...] Compute dilution of precision (DOP) for an observation epoch It should be noted, that the weight of observations is not considered. The observation weight matrix is assumed to be an identity matrix. The cofactor matrix Q is related to a topocentric coordinate system (north, east, up): | q_nn q_ne q_nu q_nt | Q = | q_ne q_ee q_eu q_et | | q_nu q_eu q_nn q_nt | | q_nt q_et q_nt q_tt | Reference: Banerjee, P. and Bose, A. (1996): \"Evaluation of GPS PDOP from elevation and azimuth of satellites\", Indian Journal of Radio & Space Physics, Vol. 25, April 1996, pp. 110-113 Args: az : Satellite azimuth angle (radians) el : Satellite elevation angle (radians) Returns: Tuple with GDOP, PDOP, TDOP, HDOP and VDOP","title":"compute_dops()"},{"location":"api/midgard-gnss/#midgardgnssgnss","text":"Midgard library module including functions for GNSS modeling Example: from migard.gnss import gnss Description: This module will provide functions for GNSS modeling.","title":"midgard.gnss.gnss"},{"location":"api/midgard-gnss/#get_number_of_satellites","text":"Full name: midgard.gnss.gnss.get_number_of_satellites Signature: (systems: numpy.ndarray, satellites: numpy.ndarray, epochs: numpy.ndarray) -> numpy.ndarray Get number of satellites per epoch Args: satellites : Array with satellite PRN number together with GNSS identifier (e.g. G07) systems : Array with GNSS identifiers (e.g. G, E, R, ...) epochs : Array with observation epochs (e.g. as datetime objects) Returns: Number of satellites per epoch","title":"get_number_of_satellites()"},{"location":"api/midgard-gnss/#get_rinex_file_version","text":"Full name: midgard.gnss.gnss.get_rinex_file_version Signature: (file_path: pathlib.PosixPath) -> str Get RINEX file version for a given file path Args: file_path : File path. Returns: RINEX file version","title":"get_rinex_file_version()"},{"location":"api/midgard-gnss/#obstype_to_freq","text":"Full name: midgard.gnss.gnss.obstype_to_freq Signature: (sys: str, obstype: str) -> float Get GNSS frequency based on given GNSS observation type Args: sys : GNSS identifier (e.g. 'E', 'G', ...) obstype : Observation type (e.g. 'L1', 'P1', 'C1X', ...) Return: GNSS frequency in [Hz]","title":"obstype_to_freq()"},{"location":"api/midgard-gnss/#midgardgnssrec_velocity_est","text":"","title":"midgard.gnss.rec_velocity_est"},{"location":"api/midgard-gnss/#e_omga-float","text":"E_OMGA = 7.2921151467e-05","title":"E_OMGA (float)"},{"location":"api/midgard-gnss/#epilog-str","text":"epilog = '\\n**EXAMPLE**\\n rec_velocity_est.py \\n args:\\n NONE\\n \\n**COPYRIGHT**\\n | Copyright 2019, by the Geodetic Institute, NMA\\n | All rights reserved\\n\\n**AUTHORS**\\n | Mohammed Ouassou \\n | Geodetic Institute, NMA\\n | Kartverksveien 21, N-3511\\n | H\u00f8nefoss, Norway\\n \\n'","title":"epilog (str)"},{"location":"api/midgard-gnss/#lambda_e1-float","text":"lambda_E1 = 0.19029367279836487","title":"lambda_E1 (float)"},{"location":"api/midgard-gnss/#prolog-str","text":"prolog = '\\n**PROGRAM**\\n rec_velocity_est.py\\n \\n**PURPOSE**\\n \"GNSS Receiver velocity estimation by Doppler measurements\\n \\n Doppler shift, affecting the frequency of the signal received from a GNSS satellite, is related to the user-satellite relative motion \\n and is useful to study the receiver motion. Using measurements from at least four simultaneous Doppler measurements, Least Square (LS) \\n or Kalman filter (KF) estimation techniques can be employed to obtain an estimate of the four unknown dx=(Vx, Vy, Vz, rate(cdt) ).\\n \\n FACTS:\\n F.1 The design matrix H of the Doppler based velocity model is the same as the pseudorange case. Constellation geometry influences the \\n velocity accuracy according to DOP.\\n F.2 The measurement errors is composed of systematic errors (orbital errors, atmosphere, and so forth) and the measurement noise. \\n Noting that the Doppler is the time derivative of the carrier phase, the systematic Doppler errors are the time derivative of the \\n carrier phase errors and changing slowly with time. The magnitude is at the level of millimeters per seconds. \\n F.3 Geometry factors influences the estimation process. \\n F.4 The implementation is based on the paper of Mark Petovello (GNSS solutions).\\n \\n VALIDATION:\\n V.1 CNES software package SPRING is used to validate the implemented SPV.\\n V.2 Solution validation is based on Chi-square test and GDOP values on epoch-by-epoch basis\\n \\n**USAGE**\\n'","title":"prolog (str)"},{"location":"api/midgard-gnss/#spvdoppler","text":"Full name: midgard.gnss.rec_velocity_est.spvDoppler Signature: (z, H, x, dx, Qx)","title":"spvDoppler"},{"location":"api/midgard-gnss/#midgardgnsssolution_validation","text":"","title":"midgard.gnss.solution_validation"},{"location":"api/midgard-gnss/#comp_quality_indicators","text":"Full name: midgard.gnss.solution_validation.comp_quality_indicators Signature: (sol_vc_mat: numpy.ndarray) -> tuple Compute quality indicators Following quality indicators are computed 1. compute the standard error ellipse(SEE) 2. compute the distance root mean squared (DRMS) 3. compute the circular error probable (CEP) Args: sol_vc_mat : Variance-covariance matrix of the unknown Returns: Tuple with DRMS, CEP and SEE","title":"comp_quality_indicators()"},{"location":"api/midgard-gnss/#epilog-str_1","text":"epilog = '\\n**EXAMPLE**\\n sol_validation (residuals, alpha_sign_level n_params)\\n args:\\n residuals (I): postfit residuals \\n alpha_sign_level(I): alpha significance level and defines the rejection area.\\n possible values of alpha = 0.05 (95%), 0.01 (99%) and 0.001 (99.9%)\\n n_params (I): number of estimated parameters (states).\\n \\n\\nKeywords: Chi-square distribution,\\n'","title":"epilog (str)"},{"location":"api/midgard-gnss/#get_my_parser","text":"Full name: midgard.gnss.solution_validation.get_my_parser Signature: ()","title":"get_my_parser()"},{"location":"api/midgard-gnss/#main","text":"Full name: midgard.gnss.solution_validation.main Signature: () Main program for testing solution validation implementation","title":"main()"},{"location":"api/midgard-gnss/#todo-this-should-be-done-via-midgardtestsgnss","text":"","title":"TODO: This should be done via midgard/tests/gnss !!!"},{"location":"api/midgard-gnss/#prolog-str_1","text":"prolog = '\\n**PROGRAM**\\n solution_validation.py\\n \\n**PURPOSE**\\n Perform Chi-square test for residuals. Degrees of freedom (df) refers to the number of values that\\n are free to vary df = number of valid satellites (nv) - number of parameters to be estimated (nx) - 1.\\n GNSS solution validation based on the argument alpha, the level of significance (e.g. 99%), and\\n defines the rejection level of the crossing events. \\n Note that this is different from the false alarm rate, which instead refers to error type I\\n \\n**USAGE**\\n'","title":"prolog (str)"},{"location":"api/midgard-gnss/#sol_validation","text":"Full name: midgard.gnss.solution_validation.sol_validation Signature: (residuals: numpy.ndarray, alpha_siglev: float, n_params: int = 4) -> bool Validating the GNSS solution is carried out using Chi-square test Use Chi-square test for outlier detection and rejection. Args: residuals : Postfit residuals for all satellites in each epoch alpha_siglev : Alpha significance level n_params : Number of parameters (states), normally 4 parameters for station coordinates and receiver clock Returns: Array containing False for observations to throw away.","title":"sol_validation()"},{"location":"api/midgard-ionosphere/","text":"midgard.ionosphere midgard.ionosphere.klobuchar Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013 klobuchar () Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7fa9957b3dc0>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard. main () Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphere","text":"","title":"midgard.ionosphere"},{"location":"api/midgard-ionosphere/#midgardionosphereklobuchar","text":"Klobuchar model for computing the ionospheric time-delay correction. Description: Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model). GPS and Beidu satellite navigation systems use this model. The implementation is based on original paper of Klobuchar (1987). The Klobuchar model is also described in Figure 20-4 in IS-GPS-200J. References: IS-GPS-200J (2018): \"Global positioning systems directorate systems engineering & integration interface specification IS-GPS-200, Navstar GPS space Segment/Navigation user segment interfaces, 25. April 2018 Klobuchar, J.A. (1987): \"Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users\", IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-23, No. 3, May 1987, https://scinapse.io/papers/2058160370 Sanz Subirana, J., Juan Zornoza, J.M. and Hernandez-Pajares, M. (2013): \"GNSS data processing - Volume I: Fundamentals and Algorithms\", TM-23/1, European Space Agency, May 2013","title":"midgard.ionosphere.klobuchar"},{"location":"api/midgard-ionosphere/#klobuchar","text":"Full name: midgard.ionosphere.klobuchar.klobuchar Signature: (time, ion_coeffs, rec_pos, az, el, freq_l1, freq=None, logger=functools.partial(<function log at 0x7fa9957b3dc0>, level='debug')) Compute the ionospheric time-delay correction for the single-frequency by broadcast model (klobuchar model) GPS and BeiDou satellite navigation systems use this model. The implementation is based on original paper of Klobuchar, J.A. Ionospheric Time-Delay Algorithm for Single-Frequency GPS Users https://scinapse.io/papers/2058160370 Args: time : GPST ion_coeffs : iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3} as vector rec_pos : receiver position {lat,lon,h} [rad, rad, m] as vector az : azimuth angle [rad] el : elevation angle [rad] system : GNSS system freq_l1 : L1 frequency of given GNSS in [Hz] freq : Frequency in [Hz] for which ionospheric delay should be determined. logger : Function that logs Returns: iono_delay : computed path delay for given frequency [m] L1_variance : corresponding variance [m^2] TODO: freq_L1 should be determined in klobuchar routine and argument be replaced by system. constants needed in Midgard.","title":"klobuchar()"},{"location":"api/midgard-ionosphere/#main","text":"Full name: midgard.ionosphere.klobuchar.main Signature: ()","title":"main()"},{"location":"api/midgard-math/","text":"midgard.math midgard.math.constant Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit). Constant Full name: midgard.math.constant.Constant Signature: () -> None constant (Constant) constant = Constant('/home/kirann/miniconda3/lib/python3.8/site-packages/midgard/math/constant.txt') midgard.math.ellipsoid Midgard library module for handling Earth ellipsoids Description: Ellipsoid Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name: str, a: float, f_inv: float, description: str) -> None Ellipsoid(name: str, a: float, f_inv: float, description: str) GRS80 (Ellipsoid) GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS') IERS2003 (Ellipsoid) IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12') IERS2010 (Ellipsoid) IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18') WGS72 (Ellipsoid) WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72') WGS84 (Ellipsoid) WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS') get () Full name: midgard.math.ellipsoid.get Signature: (ellipsoid: str) -> 'Ellipsoid' Get an ellipsoid by name sphere (Ellipsoid) sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius') midgard.math.interpolation Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) barycentric_interpolator () Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function cubic () Full name: midgard.math.interpolation.cubic Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function get_interpolator () Full name: midgard.math.interpolation.get_interpolator Signature: (name: str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name. interpolate () Full name: midgard.math.interpolation.interpolate Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values. interpolate_with_derivative () Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, dx: float = 0.5, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives. interpolated_univariate_spline () Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function interpolators () Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators. lagrange () Full name: midgard.math.interpolation.lagrange Signature: (x: numpy.ndarray, y: numpy.ndarray, *, window: int = 10, bounds_error: bool = True, assume_sorted: bool = False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function. linear () Full name: midgard.math.interpolation.linear Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function register_interpolator () Full name: midgard.math.interpolation.register_interpolator Signature: (func: Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function. midgard.math.linear_regression Midgard library module for linear regression Description: LinearRegression Full name: midgard.math.linear_regression.LinearRegression Signature: (x: numpy.ndarray, y: numpy.ndarray) -> None LinearRegression(x: numpy.ndarray, y: numpy.ndarray) midgard.math.nputil Utility wrapper for numpy functions Makes sure numpy functions can be called in a similar fashion for different use cases + both 1- and 2-dimensional input + both single values and arrays HashArray Full name: midgard.math.nputil.HashArray Signature: (val) col () Full name: midgard.math.nputil.col Signature: (vector) hashable () Full name: midgard.math.nputil.hashable Signature: (func) Decorator for functions with numpy arrays as input arguments that will benefit from caching Example: from midgard.math import nputil from functools import lru_cache @nputil.hashable @lru_cache() def test_func(a: np.ndarray, b: np.ndarray = None) do_something return something norm () Full name: midgard.math.nputil.norm Signature: (vector) row () Full name: midgard.math.nputil.row Signature: (vector) take () Full name: midgard.math.nputil.take Signature: (vector, item) unit_vector () Full name: midgard.math.nputil.unit_vector Signature: (vector) midgard.math.planetary_motion Midgard library for planetary motion Example: from migard.math import planetary_motion findsun () Full name: midgard.math.planetary_motion.findsun Signature: (time: 'Time') -> numpy.ndarray Obtains the position vector of the Sun in relation to Earth (in ECEF). This routine is a reimplementation of routine findSun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Sun position vector given in ECEF [m] gsdtime_sun () Full name: midgard.math.planetary_motion.gsdtime_sun Signature: (time: 'Time') -> Tuple[numpy.ndarray] Get position of the sun (low-precision) This routine is a reimplementation of routine GSDtime_sun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Tuple with following entries: Elements Description gstr GMST0 (to go from ECEF to inertial) [deg] slong Sun longitude [deg] sra Sun right Ascension [deg] sdec Sun declination in [deg] midgard.math.rotation Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]]) R1 () Full name: midgard.math.rotation.R1 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R2 () Full name: midgard.math.rotation.R2 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. R3 () Full name: midgard.math.rotation.R3 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR1 () Full name: midgard.math.rotation.dR1 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR2 () Full name: midgard.math.rotation.dR2 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. dR3 () Full name: midgard.math.rotation.dR3 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices. enu2trs () Full name: midgard.math.rotation.enu2trs Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. np_float (TypeVar) np_float = ~np_float trs2enu () Full name: midgard.math.rotation.trs2enu Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices. midgard.math.transformation Midgard library module for handling of geodetic conversions Description: delta_acr2trs_posvel () Full name: midgard.math.transformation.delta_acr2trs_posvel Signature: (acr: 'AcrPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ACR to TRS delta_enu2trs () Full name: midgard.math.transformation.delta_enu2trs Signature: (enu: 'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS delta_enu2trs_posvel () Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu: 'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS delta_trs2acr_posvel () Full name: midgard.math.transformation.delta_trs2acr_posvel Signature: (trs: 'TrsPosVelDelta') -> 'AcrPosVelDelta' Convert position deltas from TRS to ACR delta_trs2enu () Full name: midgard.math.transformation.delta_trs2enu Signature: (trs: 'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU delta_trs2enu_posvel () Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs: 'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU kepler2trs () Full name: midgard.math.transformation.kepler2trs Signature: (kepler: 'KeplerPosVel') -> 'TrsPosVel' Compute orbit position and velocity vector in geocentric equatorial coordinate system based on Keplerian elements for elliptic orbits. The implementation is based on Section 2.2.3 in :cite: montenbruck2012 . llh2trs () Full name: midgard.math.transformation.llh2trs Signature: (llh: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection. trs2kepler () Full name: midgard.math.transformation.trs2kepler Signature: (trs: 'TrsPosVel') -> 'KeplerPosVel' Compute Keplerian elements for elliptic orbit based on orbit position and velocity vector given in ITRS. The used equations are described in Section 2.2.4 in Montenbruck :cite: montenbruck2012 . The position and velocity vector in ITRS and GM must be given in consistent units, which are [m], [m/s] and [m^3/s^2]. The resulting unit of the semimajor axis is implied by the unity of the position vector, i.e. [m]. .. note:: The function cannot be used with position/velocity vectors describing a circular or non-inclined orbit. Returns: tuple with numpy.ndarray types: Tuple with following Keplerian elements: =============== ====== ================================================================================== Keys Unit Description =============== ====== ================================================================================== a m Semimajor axis e Eccentricity of the orbit i rad Inclination Omega rad Right ascension of the ascending node omega rad Argument of perigee E rad Eccentric anomaly =============== ====== ================================================================================== trs2llh () Full name: midgard.math.transformation.trs2llh Signature: (trs: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection. midgard.math.unit Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory. Unit Full name: midgard.math.unit.Unit Signature: (from_unit: str, to_unit: Union[str, NoneType] = None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass. fid (TextIOWrapper) fid = <_io.TextIOWrapper name='/home/kirann/miniconda3/lib/python3.8/site-packages/midgard/math/unit.txt' encoding='utf-8'> np_float (TypeVar) np_float = ~np_float","title":"midgard.math"},{"location":"api/midgard-math/#midgardmath","text":"","title":"midgard.math"},{"location":"api/midgard-math/#midgardmathconstant","text":"Midgard library module defining an assortment of constants Description: This module provides constants that are used within the Midgard project. The actual constants are defined in the constants.conf file (see the file list for location). See that file for references and for adding or changing constants. The constants are stored as module variables so they can be used simply as constant.c as in the example above. Some models use particular values for constants that are different from the conventional ones. This is handled by the source parameter. For instance, the EGM 2008 gravity field is calculated with a value for GM different from the IERS Conventions value, using:: constant.get('GM', source='egm_2008') instead of simply constant.GM . Example: >>> from midgard.math.constant import Constant >>> print(f\"The speed of light is {constant.c:0.2f}\") The speed of light is 299792458.00 Todo: Rewrite as a class instead of a module, to have somewhat cleaner code (and be more consistent with things like lib.unit).","title":"midgard.math.constant"},{"location":"api/midgard-math/#constant","text":"Full name: midgard.math.constant.Constant Signature: () -> None","title":"Constant"},{"location":"api/midgard-math/#constant-constant","text":"constant = Constant('/home/kirann/miniconda3/lib/python3.8/site-packages/midgard/math/constant.txt')","title":"constant (Constant)"},{"location":"api/midgard-math/#midgardmathellipsoid","text":"Midgard library module for handling Earth ellipsoids Description:","title":"midgard.math.ellipsoid"},{"location":"api/midgard-math/#ellipsoid","text":"Full name: midgard.math.ellipsoid.Ellipsoid Signature: (name: str, a: float, f_inv: float, description: str) -> None Ellipsoid(name: str, a: float, f_inv: float, description: str)","title":"Ellipsoid"},{"location":"api/midgard-math/#grs80-ellipsoid","text":"GRS80 = Ellipsoid(name='GRS80', a=6378137, f_inv=298.257222101, description='Used by ITRS')","title":"GRS80 (Ellipsoid)"},{"location":"api/midgard-math/#iers2003-ellipsoid","text":"IERS2003 = Ellipsoid(name='IERS2003', a=6378136.6, f_inv=298.25642, description='IERS conventions 2003, p. 12')","title":"IERS2003 (Ellipsoid)"},{"location":"api/midgard-math/#iers2010-ellipsoid","text":"IERS2010 = Ellipsoid(name='IERS2010', a=6378136.6, f_inv=298.25642, description='IERS conventions 2010, p. 18')","title":"IERS2010 (Ellipsoid)"},{"location":"api/midgard-math/#wgs72-ellipsoid","text":"WGS72 = Ellipsoid(name='WGS72', a=6378135, f_inv=298.26, description='WGS72')","title":"WGS72 (Ellipsoid)"},{"location":"api/midgard-math/#wgs84-ellipsoid","text":"WGS84 = Ellipsoid(name='WGS84', a=6378137, f_inv=298.257223563, description='Used by GPS')","title":"WGS84 (Ellipsoid)"},{"location":"api/midgard-math/#get","text":"Full name: midgard.math.ellipsoid.get Signature: (ellipsoid: str) -> 'Ellipsoid' Get an ellipsoid by name","title":"get()"},{"location":"api/midgard-math/#sphere-ellipsoid","text":"sphere = Ellipsoid(name='sphere', a=6371008.8, f_inv=inf, description='Regular sphere, mean radius')","title":"sphere (Ellipsoid)"},{"location":"api/midgard-math/#midgardmathinterpolation","text":"Methods for interpolating in numpy arrays Description: Different interpolation methods are decorated with @register_interpolator and will then become available for use as kind in interpolate and moving_window . Example: >>> import numpy as np >>> np.set_printoptions(precision=3, suppress=True) >>> x = np.linspace(-1, 1, 11) >>> y = x**3 - x >>> y array([ 0. , 0.288, 0.384, 0.336, 0.192, 0. , -0.192, -0.336, -0.384, -0.288, 0. ]) >>> x_new = np.linspace(-0.8, 0.8, 11) >>> interpolate(x, y, x_new, kind='cubic') array([ 0.288, 0.378, 0.369, 0.287, 0.156, -0. , -0.156, -0.287, -0.369, -0.378, -0.288]) Developer info: To add your own interpolators, you can simply decorate your interpolator functions with @register_interpolator . Your interpolator function should have the signature (x: np.ndarray, y: np.ndarray) -> Callable For instance, the following would implement a terrible interpolation function that sets all values to zero: from midgard.math.interpolation import register_interpolator @register_interpolator def zero(x: np.ndarray, y: np.ndarray) -> Callable: def _zero(x_new: np.ndarray) -> np.ndarray: return np.zeros(y.shape) return _zero This function would then be available as an interpolator. For instance, one could do >>> interpolate(x, y, x_new, kind='zero') # doctest: +SKIP array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])","title":"midgard.math.interpolation"},{"location":"api/midgard-math/#barycentric_interpolator","text":"Full name: midgard.math.interpolation.barycentric_interpolator Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable The interpolating polynomial through the given points Uses the scipy.interpolate.BarycentricInterpolator function behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Barycentric interpolation function","title":"barycentric_interpolator()"},{"location":"api/midgard-math/#cubic","text":"Full name: midgard.math.interpolation.cubic Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Cubic spline interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='cubic' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Cubic spline interpolation function","title":"cubic()"},{"location":"api/midgard-math/#get_interpolator","text":"Full name: midgard.math.interpolation.get_interpolator Signature: (name: str) -> Callable Return an interpolation function Interpolation functions are registered by the @register_interpolator-decorator. The name-parameter corresponds to the function name of the interpolator. Args: name : Name of interpolator. Returns: Interpolation function with the given name.","title":"get_interpolator()"},{"location":"api/midgard-math/#interpolate","text":"Full name: midgard.math.interpolation.interpolate Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. ipargs : Keyword arguments passed on to the interpolator. Returns: Array of interpolated y-values.","title":"interpolate()"},{"location":"api/midgard-math/#interpolate_with_derivative","text":"Full name: midgard.math.interpolation.interpolate_with_derivative Signature: (x: numpy.ndarray, y: numpy.ndarray, x_new: numpy.ndarray, *, kind: str, dx: float = 0.5, **ipargs: Any) -> numpy.ndarray Interpolate values from one x-array to another as well as find derivatives See interpolators() for a list of valid interpolators. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. x_new : 1-dimensional array with new x-values. kind : Name of interpolator to use. dx : Values at x \u00b1 dx are used to determine derivative. ipargs : Keyword arguments passed on to the interpolator. Returns: Tuple with array of interpolated y-values and array of derivatives.","title":"interpolate_with_derivative()"},{"location":"api/midgard-math/#interpolated_univariate_spline","text":"Full name: midgard.math.interpolation.interpolated_univariate_spline Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable One-dimensional interpolating spline for the given points Uses the scipy.interpolate.InterpolatedUnivariateSpline function behind the scenes. The original only deals with one-dimensional y arrays, so multiple calls are made for higher dimensional y arrays. The dimensions are handled independently of each other. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the scipy-interpolator. Returns: Interpolating spline function","title":"interpolated_univariate_spline()"},{"location":"api/midgard-math/#interpolators","text":"Full name: midgard.math.interpolation.interpolators Signature: () -> List[str] Return a list of available interpolators Returns: Names of available interpolators.","title":"interpolators()"},{"location":"api/midgard-math/#lagrange","text":"Full name: midgard.math.interpolation.lagrange Signature: (x: numpy.ndarray, y: numpy.ndarray, *, window: int = 10, bounds_error: bool = True, assume_sorted: bool = False) -> Callable Computes the lagrange polynomial passing through a certain set of points See https://en.wikipedia.org/wiki/Lagrange_polynomial Uses window of the original points to calculate the Lagrange polynomials. The window of points is chosen by finding the closest original point and essentially picking the window // 2 indices on either side. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. window : Number of points used in interpolation. bounds_error : If True, a ValueError is raised if extrapolation is attempted. assume_sorted : If True, x must be an array of monotonically increasing values. Returns: Lagrange interpolation function.","title":"lagrange()"},{"location":"api/midgard-math/#linear","text":"Full name: midgard.math.interpolation.linear Signature: (x: numpy.ndarray, y: numpy.ndarray, **ipargs: Any) -> Callable Linear interpolation through the given points Uses the scipy.interpolate.interp1d function with kind='linear' behind the scenes. Args: x : 1-dimensional array with original x-values. y : Array with original y-values. ipargs : Keyword arguments passed on to the interp1d-interpolator. Returns: Linear interpolation function","title":"linear()"},{"location":"api/midgard-math/#register_interpolator","text":"Full name: midgard.math.interpolation.register_interpolator Signature: (func: Callable) -> Callable Register an interpolation function This function should be used as a @register_interpolator-decorator Args: func : Function that will be registered as an interpolator. Returns: Same function.","title":"register_interpolator()"},{"location":"api/midgard-math/#midgardmathlinear_regression","text":"Midgard library module for linear regression Description:","title":"midgard.math.linear_regression"},{"location":"api/midgard-math/#linearregression","text":"Full name: midgard.math.linear_regression.LinearRegression Signature: (x: numpy.ndarray, y: numpy.ndarray) -> None LinearRegression(x: numpy.ndarray, y: numpy.ndarray)","title":"LinearRegression"},{"location":"api/midgard-math/#midgardmathnputil","text":"Utility wrapper for numpy functions Makes sure numpy functions can be called in a similar fashion for different use cases + both 1- and 2-dimensional input + both single values and arrays","title":"midgard.math.nputil"},{"location":"api/midgard-math/#hasharray","text":"Full name: midgard.math.nputil.HashArray Signature: (val)","title":"HashArray"},{"location":"api/midgard-math/#col","text":"Full name: midgard.math.nputil.col Signature: (vector)","title":"col()"},{"location":"api/midgard-math/#hashable","text":"Full name: midgard.math.nputil.hashable Signature: (func) Decorator for functions with numpy arrays as input arguments that will benefit from caching Example: from midgard.math import nputil from functools import lru_cache @nputil.hashable @lru_cache() def test_func(a: np.ndarray, b: np.ndarray = None) do_something return something","title":"hashable()"},{"location":"api/midgard-math/#norm","text":"Full name: midgard.math.nputil.norm Signature: (vector)","title":"norm()"},{"location":"api/midgard-math/#row","text":"Full name: midgard.math.nputil.row Signature: (vector)","title":"row()"},{"location":"api/midgard-math/#take","text":"Full name: midgard.math.nputil.take Signature: (vector, item)","title":"take()"},{"location":"api/midgard-math/#unit_vector","text":"Full name: midgard.math.nputil.unit_vector Signature: (vector)","title":"unit_vector()"},{"location":"api/midgard-math/#midgardmathplanetary_motion","text":"Midgard library for planetary motion Example: from migard.math import planetary_motion","title":"midgard.math.planetary_motion"},{"location":"api/midgard-math/#findsun","text":"Full name: midgard.math.planetary_motion.findsun Signature: (time: 'Time') -> numpy.ndarray Obtains the position vector of the Sun in relation to Earth (in ECEF). This routine is a reimplementation of routine findSun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Sun position vector given in ECEF [m]","title":"findsun()"},{"location":"api/midgard-math/#gsdtime_sun","text":"Full name: midgard.math.planetary_motion.gsdtime_sun Signature: (time: 'Time') -> Tuple[numpy.ndarray] Get position of the sun (low-precision) This routine is a reimplementation of routine GSDtime_sun() in model.c of gLAB 3.0.0 software. The gLAB 3.0.0 software core excecutables are distributed under the Apache License version 2.0 related to following copyright and license: COPYRIGHT 2009 - 2016 GAGE/UPC & ESA LICENSED UNDER THE APACHE LICENSE, VERSION 2.0 (THE \"LICENSE\"); YOU MAY NOT USE THIS ROUTINE EXCEPT IN COMPLIANCE WITH THE LICENSE. YOU MAY OBTAIN A COPY OF THE LICENSE AT HTTP://WWW.APACHE.ORG/LICENSES/LICENSE-2.0 UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING, SOFTWARE DISTRIBUTED UNDER THE LICENSE IS DISTRIBUTED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. SEE THE LICENSE FOR THE SPECIFIC LANGUAGE GOVERNING PERMISSIONS AND LIMITATIONS UNDER THE LICENSE. Args: time : Time object Returns: Tuple with following entries: Elements Description gstr GMST0 (to go from ECEF to inertial) [deg] slong Sun longitude [deg] sra Sun right Ascension [deg] sdec Sun declination in [deg]","title":"gsdtime_sun()"},{"location":"api/midgard-math/#midgardmathrotation","text":"Library for basic rotation matrices Description: Creates rotation matrices for rotation around the axes of a right handed Cartesian coordinate system and their derivatives. For instance, for an XYZ-system, R1 returns a rotation matrix around the x-axis and for an ENU-system, R1 returns a rotation matrix around the east-axis. dR1 returns the derivative of the R1 matrix with respect to the rotation angle. All functions are vectorized, so that one rotation matrix is returned per input angle. Example: from where.lib import rotation rotation.R1([0, 1]) array([[[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [ 0. , -0. , 1. ]], [[ 1. , 0. , 0. ], [ 0. , 0.54030231, 0.84147098], [ 0. , -0.84147098, 0.54030231]]])","title":"midgard.math.rotation"},{"location":"api/midgard-math/#r1","text":"Full name: midgard.math.rotation.R1 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the first axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R1()"},{"location":"api/midgard-math/#r2","text":"Full name: midgard.math.rotation.R2 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the second axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R2()"},{"location":"api/midgard-math/#r3","text":"Full name: midgard.math.rotation.R3 Signature: (angle: ~np_float) -> numpy.ndarray Rotation matrix around the third axis Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"R3()"},{"location":"api/midgard-math/#dr1","text":"Full name: midgard.math.rotation.dR1 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the first axis with respect to the rotation angle. Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR1()"},{"location":"api/midgard-math/#dr2","text":"Full name: midgard.math.rotation.dR2 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the second axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR2()"},{"location":"api/midgard-math/#dr3","text":"Full name: midgard.math.rotation.dR3 Signature: (angle: ~np_float) -> numpy.ndarray Derivative of a rotation matrix around the third axis with respect to the rotation angle Args: angle : Scalar, list or numpy array of angles in radians. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"dR3()"},{"location":"api/midgard-math/#enu2trs","text":"Full name: midgard.math.rotation.enu2trs Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an ENU coordinate system to an earth oriented one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R3(-(np.pi/2 + lon)) @ R1(-(np.pi/2 - lat)) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"enu2trs()"},{"location":"api/midgard-math/#np_float-typevar","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-math/#trs2enu","text":"Full name: midgard.math.rotation.trs2enu Signature: (lat: ~np_float, lon: ~np_float) -> numpy.ndarray Rotation matrix for rotating an earth oriented coordinate system to an ENU one See for instance http://www.navipedia.net/index.php/Transformations_between_ECEF_and_ENU_coordinates This is equal to doing:: R1(np.pi/2 - lat) @ R3(np.pi/2 + lon) Args: lat (Float or Array): Latitude of origin of ENU coordinate system. lon (Float or Array): Longitude of origin of ENU coordinate system. Returns: Numpy array: Rotation matrix or array of rotation matrices.","title":"trs2enu()"},{"location":"api/midgard-math/#midgardmathtransformation","text":"Midgard library module for handling of geodetic conversions Description:","title":"midgard.math.transformation"},{"location":"api/midgard-math/#delta_acr2trs_posvel","text":"Full name: midgard.math.transformation.delta_acr2trs_posvel Signature: (acr: 'AcrPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ACR to TRS","title":"delta_acr2trs_posvel()"},{"location":"api/midgard-math/#delta_enu2trs","text":"Full name: midgard.math.transformation.delta_enu2trs Signature: (enu: 'EnuPositionDelta') -> 'TrsPositionDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs()"},{"location":"api/midgard-math/#delta_enu2trs_posvel","text":"Full name: midgard.math.transformation.delta_enu2trs_posvel Signature: (enu: 'EnuPosVelDelta') -> 'TrsPosVelDelta' Convert position deltas from ENU to TRS","title":"delta_enu2trs_posvel()"},{"location":"api/midgard-math/#delta_trs2acr_posvel","text":"Full name: midgard.math.transformation.delta_trs2acr_posvel Signature: (trs: 'TrsPosVelDelta') -> 'AcrPosVelDelta' Convert position deltas from TRS to ACR","title":"delta_trs2acr_posvel()"},{"location":"api/midgard-math/#delta_trs2enu","text":"Full name: midgard.math.transformation.delta_trs2enu Signature: (trs: 'TrsPositionDelta') -> 'EnuPositionDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu()"},{"location":"api/midgard-math/#delta_trs2enu_posvel","text":"Full name: midgard.math.transformation.delta_trs2enu_posvel Signature: (trs: 'TrsPosVelDelta') -> 'EnuPosVelDelta' Convert position deltas from TRS to ENU","title":"delta_trs2enu_posvel()"},{"location":"api/midgard-math/#kepler2trs","text":"Full name: midgard.math.transformation.kepler2trs Signature: (kepler: 'KeplerPosVel') -> 'TrsPosVel' Compute orbit position and velocity vector in geocentric equatorial coordinate system based on Keplerian elements for elliptic orbits. The implementation is based on Section 2.2.3 in :cite: montenbruck2012 .","title":"kepler2trs()"},{"location":"api/midgard-math/#llh2trs","text":"Full name: midgard.math.transformation.llh2trs Signature: (llh: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geodetic latitude-, longitude-, height-coordinates to geocentric xyz-coordinates Reimplementation of GD2GCE.for from the IUA SOFA software collection.","title":"llh2trs()"},{"location":"api/midgard-math/#trs2kepler","text":"Full name: midgard.math.transformation.trs2kepler Signature: (trs: 'TrsPosVel') -> 'KeplerPosVel' Compute Keplerian elements for elliptic orbit based on orbit position and velocity vector given in ITRS. The used equations are described in Section 2.2.4 in Montenbruck :cite: montenbruck2012 . The position and velocity vector in ITRS and GM must be given in consistent units, which are [m], [m/s] and [m^3/s^2]. The resulting unit of the semimajor axis is implied by the unity of the position vector, i.e. [m]. .. note:: The function cannot be used with position/velocity vectors describing a circular or non-inclined orbit. Returns: tuple with numpy.ndarray types: Tuple with following Keplerian elements: =============== ====== ================================================================================== Keys Unit Description =============== ====== ================================================================================== a m Semimajor axis e Eccentricity of the orbit i rad Inclination Omega rad Right ascension of the ascending node omega rad Argument of perigee E rad Eccentric anomaly =============== ====== ==================================================================================","title":"trs2kepler()"},{"location":"api/midgard-math/#trs2llh","text":"Full name: midgard.math.transformation.trs2llh Signature: (trs: numpy.ndarray, ellipsoid: midgard.math.ellipsoid.Ellipsoid = None) -> numpy.ndarray Convert geocentric xyz-coordinates to geodetic latitude-, longitude-, height-coordinates Reimplementation of GC2GDE.for from the IUA SOFA software collection.","title":"trs2llh()"},{"location":"api/midgard-math/#midgardmathunit","text":"Midgard library module for handling of SI-unit conversions Description: This module provides unit conversion constants and functions. The heavy lifting is done by the pint package. The basic usage is as follows: >>> from midgard.math.unit import Unit >>> seconds_in_two_weeks = 2 * Unit.week2secs >>> seconds_in_two_weeks 1209600.0 In general Unit.spam2ham will give the multiplicative conversion scale between the units spam and ham . Through the pint package we support a lot of units. See Unit.list() or https://github.com/hgrecco/pint/blob/master/pint/default_en.txt . Another notation is also available, and might be necessary for some more complicated conversions: >>> seconds_in_two_weeks = 2 * Unit('week', 'seconds') >>> miles_per_hour_in_meters_per_second = Unit('mph', 'meters / sec') Do note that we support most normal aliases as well as singular and plural forms of the units. For instance can second be represented as s , sec , secs and seconds . Prefixes are also handled: >>> nanoseconds_in_an_hour = Unit.hour2nanosecs >>> inches_in_a_kilometer = Unit.km2inches For more complicated conversions (for instance from Celsius to Fahrenheit) one can create custom conversion functions using convert : >>> c2f = Unit.function('celsius', 'fahrenheit') >>> absolute_zero_in_fahrenheit = c2f(-273.15) For convenience, this can also be written using the attribute notation as Unit.spam_to_ham(spam_value) . Then the previous example simply becomes: >>> absolute_zero_in_fahrenheit = Unit.celsius_to_fahrenheit(-273.15) (or even easier Unit.kelvin_to_fahrenheit(0) ). Finally, we can access the unit/quantity system of pint by using the name of a unit by itself, e.g. Unit.spam . For instance: >>> distance = 42 * Unit.km >>> time = 31 * Unit('minutes') >>> speed = distance / time >>> speed.to(Unit.mph) <Quantity(50.511464659292955, 'mph')> >>> speed.to_base_units() <Quantity(22.580645161290324, 'meter / second')> However, using the full unit system adds some overhead so we should be careful in using it in heavy calculations. Note that pint has a system for defining new units and constants if necessary, http://pint.readthedocs.io/en/latest/defining.html . To use this system, add units to the unit.txt file in the current (midgard/math) directory.","title":"midgard.math.unit"},{"location":"api/midgard-math/#unit","text":"Full name: midgard.math.unit.Unit Signature: (from_unit: str, to_unit: Union[str, NoneType] = None) -> Any Unit converter The implementation of the unit conversion is done in the _convert_units -metaclass.","title":"Unit"},{"location":"api/midgard-math/#fid-textiowrapper","text":"fid = <_io.TextIOWrapper name='/home/kirann/miniconda3/lib/python3.8/site-packages/midgard/math/unit.txt' encoding='utf-8'>","title":"fid (TextIOWrapper)"},{"location":"api/midgard-math/#np_float-typevar_1","text":"np_float = ~np_float","title":"np_float (TypeVar)"},{"location":"api/midgard-parsers/","text":"midgard.parsers Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser. names () Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers parse_file () Full name: midgard.parsers.parse_file Signature: (parser_name: str, file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, timer_logger: Union[Callable[[str], NoneType], NoneType] = None, use_cache: bool = False, **parser_args: Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. (TODO: implement this) parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data midgard.parsers._parser Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() Parser Full name: midgard.parsers._parser.Parser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). midgard.parsers._parser_chain Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() ChainParser Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser . ParserDef Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker: Callable[[str, int, str], bool], label: Callable[[str, int], Any], parser_def: Dict[Any, Dict[str, Any]], skip_line: Union[Callable[[str], bool], NoneType] = None, end_callback: Union[Callable[[Dict[str, Any]], NoneType], NoneType] = None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group. midgard.parsers._parser_line Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() LineParser Full name: midgard.parsers._parser_line.LineParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser . midgard.parsers._parser_rinex Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format. RinexHeader Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker: str, fields: Dict[str, Tuple[int, int]], parser: Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields. RinexParser Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs . parser_cache () Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func: Callable[[ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions midgard.parsers._parser_sinex Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html SinexBlock Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker: str, fields: Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser: Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data. SinexField Full name: midgard.parsers._parser_sinex.SinexField Signature: (name: str, start_col: int, dtype: Union[str, NoneType], converter: Union[str, NoneType] = None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data. SinexParser Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed. parsing_factory () Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block. parsing_matrix_factory () Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker: str, size_marker: str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block. midgard.parsers.anubis A parser for reading Anubis xtr-files AnubisXtrParser Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Anubis XTR files midgard.parsers.bcecmp_sisre A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR. BcecmpParser Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_with_dt_mean Satellite clock correction difference corrected for average satellite clock offset difference for given GNSS and epoch in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.csv_ A parser for reading CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='csv_', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in CSV output format. The header information of the CSV file is not read (TODO). CsvParser Full name: midgard.parsers.csv_.CsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading CSV output files The CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the CSV colum values. Following meta -data are available after reading of CSV file: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.discontinuities_snx A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuities_snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format . DiscontinuitiesSnxParser Full name: midgard.parsers.discontinuities_snx.DiscontinuitiesSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.galileo_constellation_html A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example GalileoConstellationHTMLParser Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, url: Union[str, NoneType] = None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example midgard.parsers.gipsy_tdp A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format. GipsyTdpParser Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_gdcov A parser for reading NASA JPL GipsyX gdcov format file gdcov format file includes GipsyX estimates and covariance information. NOTE: At the moment this parser can only read station estimate and covariance information, that means STA.X, STA.Y and STA.Z parameters. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_gdcov', file_path='smoothFinal.gdcov') data = p.as_dict() Description: Reads data from files in GipsyX gdcov format. GipsyxGdcovParser Full name: midgard.parsers.gipsyx_gdcov.GipsyxGdcovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX gdcov format file Following data are available after reading GipsyX gdcov output file: Key Description column Column number of correlations correlation Correlation values parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. estimate Parameter estimate at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_residual A parser for reading NASA JPL GipsyX residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_residual', file_path='finalResiduals.out') data = p.as_dict() Description: Reads data from files in GipsyX residual format. GipsyxResidualParser Full name: midgard.parsers.gipsyx_residual.GipsyxResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX residual file Following data are available after reading GipsyX residual output file: Key Description azimuth Azimuth from receiver azimuth_sat Azimuth from satellite data_type Data type (e.g. IonoFreeC_1P_2P, IonoFreeL_1P_2P) deleted Residuals are deleted, marked with True or False. elevation Elevation from receiver elevation_sat Elevation from satellite residual Post-fit residual satellite Satellite name station Station name time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_series A parser for reading NASA JPL GipsyX timeseries file Example: from analyx import parsers p = parsers.parse_file(parser_name='gipsyx_series', file_path='NYA1.series') data = p.as_dict() Description: Reads data from files in GipsyX timeseries format. GipsyxSeriesParser Full name: midgard.parsers.gipsyx_series.GipsyxSeriesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX timeseries file Following data are available after reading GipsyX residual output file: Key Description corr_en Correlation East-North. corr_ev Correlation East-Vertical. corr_nv Correlation North-Vertical. day Day decimalyear Date in unit year. east East coordinate in [m]. east_sigma Standard devication of east coordinate in [m]. hour Hour minute Minute month Month north North coordinate in [m]. north_sigma Standard devication of north coordinate in [m]. second Second time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. vertical Vertical coordinate in [m]. vertical_sigma Standard devication of vertical coordinate in [m]. year Year and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_summary A parser for reading GipsyX summary output file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_summary', file_path='gipsyx_summary') data = p.as_dict() Description: Reads data from files in GipsyX summary output format. GipsyxSummary Full name: midgard.parsers.gipsyx_summary.GipsyxSummary Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX summary file GipsyX summary file data are grouped as follows: Key Description position Dictionary with position summary information residual Dictionary with residual summary information station Station name position entries are: Key Description pos_x X-coordinate of station position solution pos_y Y-coordinate of station position solution pos_z Z-coordinate of station position solution pos_vs_ref_x X-coordinate of difference between solution and reference of station coordinate pos_vs_ref_y Y-coordinate of difference between solution and reference of station coordinate pos_vs_ref_z Z-coordinate of difference between solution and reference of station coordinate pos_vs_ref_e East-coordinate of difference between solution and reference of station coordinate pos_vs_ref_n North-coordinate of difference between solution and reference of station coordinate pos_vs_ref_v Vertical-coordinate of difference between solution and reference of station coordinate residual entries are: Key Description code_max Maximal residual of used pseudo-range observations code_min Minimal residual of used pseudo-range observations code_num Number of used pseudo-range observations code_rms RMS of residuals from used pseudo-range observations code_outlier_max Maximal residual of rejected pseudo-range observations code_outlier_min Minimal residual of rejected pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_outlier_rms RMS of residuals from rejected pseudo-range observations phase_max Maximal residual of used phase observations phase_min Minimal residual of used phase observations phase_num Number of used phase observations phase_rms RMS of residuals from used phase observations phase_outlier_max Maximal residual of rejected phase observations phase_outlier_min Minimal residual of rejected phase observations phase_outlier_num Number of rejected phase observations phase_outlier_rms RMS of residuals from rejected phase observations and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gipsyx_tdp A parser for reading NASA JPL GipsyX time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in GipsyX time dependent parameter (TDP) format. DatasetField Full name: midgard.parsers.gipsyx_tdp.DatasetField Signature: (name=None, category=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name category (str): Category of parameter (e.g. station or satellite parameter) dtype (str): Dataset data type GipsyxTdpParser Full name: midgard.parsers.gipsyx_tdp.GipsyxTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX time dependent parameter (TDP) file Following data are available after reading GipsyX TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. value Parameter value at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.glab_output A parser for reading gLAB output files Example: from midgard import parsers p = parsers.parse_file(parser_name='glab_output', file_path='glab_output.txt') data = p.as_dict() Description: GlabOutputParser Full name: midgard.parsers.glab_output.GlabOutputParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading gLAB output files The keys of the data dictionary are defined depending, which kind of gLAB output file is read. The values of the data dictionary are represented by the gLAB colum values. Following meta -data are available after reading of gLAB files: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gnss_android_raw_data A parser for reading GNSS raw data from GnssLogger Android App Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gnss_android_raw_data\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads raw data file from GnssLogger Android App. GnssAndroidRawDataParser Full name: midgard.parsers.gnss_android_raw_data.GnssAndroidRawDataParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None midgard.parsers.gnss_antex A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ). AntexParser Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file. midgard.parsers.gnss_bernese_crd A parser for reading Bernese CRD file Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_bernese_crd', file_path='W20216.CRD') data = p.as_dict() Description: Reads data from files in Bernese CRD format. GnssCrdParser Full name: midgard.parsers.gnss_bernese_crd.GnssCrdParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Bernese CRD file Following data are available after reading Bernese CRD file: Parameter Description num Number of station coordinate solution station 4-digit station identifier domes Domes number gpssec Seconds of GPS week pos_x X-coordinate of station position pos_y Y-coordinate of station position pos_z Z-coordinate of station position flag Flag and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.gnss_galat_results A parser for GALAT single point positioning result files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_galat_results', file_path='galat_results.txt') data = p.as_dict() Description: Reads data from files in GALAT result format. GalatResults Full name: midgard.parsers.gnss_galat_results.GalatResults Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GALAT single point positioning result files Following data are available after reading GALAT SPP result file: Key Description time Time epoch latitude Latitude in degree longitude Longitude in degree height Height in [m] dlatitude Latitude related to reference coordinate in [m] dlongitude Longitude related to reference coordinate in [m] dheight Height related to reference coordinate in [m] hpe Horizontal positioning error (HPE) in [m] vpe Vertical positioning error (VPE) in [m] site_vel_3d 3D site velocity in [m/s] pdop Precision dilution of precision num_satellite_available Number of available satellites num_satellite_used Number of used satellites and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name midgard.parsers.gnss_sinex_igs A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format. IgsSnxParser Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class. midgard.parsers.rinex212_nav A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex212_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.12 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.12. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ). Rinex212NavParser Full name: midgard.parsers.rinex212_nav.Rinex212NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.12 (see :cite: rinex2 ). TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_FILE_EXTENSION (dict) SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0} midgard.parsers.rinex2_nav A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.11 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.11. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ). Rinex2NavParser Full name: midgard.parsers.rinex2_nav.Rinex2NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.11 (see :cite: rinex2 ). TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ion_alpha() Parse entries of RINEX header `ION ALPHA` to instance variable `meta`. _parse_ion_beta() Parse entries of RINEX header `ION BETA` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `DELTA-UTC: A0,A1,T,W` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_FILE_EXTENSION (dict) SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0} midgard.parsers.rinex2_obs A parser for reading Rinex data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the Rinex file format 2.11 (see :cite: rinex2 ). Rinex2Parser Full name: midgard.parsers.rinex2_obs.Rinex2Parser Signature: (*args: Tuple[Any], sampling_rate: Union[NoneType, float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 2.11 (see :cite: rinex2 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. system (String): GNSS identifier. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict) SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0} midgard.parsers.rinex3_nav A parser for reading GNSS RINEX v3.03 navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 3.03 (see :cite: rinex3 ). An exception is also, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. Rinex3NavParser Full name: midgard.parsers.rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 3.03 (see :cite: rinex3 ) except for GLONASS and SBAS. TODO: Would it not be better to use one leading underscore for non-public methods and instance variables. Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale SYSNAMES (dict) SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}} SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict) SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'G': 0, 'I': 0, 'J': 0} SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict) SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'G': 0, 'I': 0, 'J': 0} midgard.parsers.rinex3_obs A parser for reading RINEX format 3.03 data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the RINEX file format version 3.03 (see :cite: rinex3 ). Rinex3Parser Full name: midgard.parsers.rinex3_obs.Rinex3Parser Signature: (*args: Tuple[Any], sampling_rate: Union[NoneType, float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 3.03 (see :cite: rinex3 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. system (String): GNSS identifier. SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict) SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0} midgard.parsers.rinex_nav A parser for reading GNSS RINEX navigation files Example: from midgard.data import dataset from midgard import parsers # Parse data parser = parsers.parse(file_path=file_path) # Create a empty Dataset dset = data.Dataset() # Fill Dataset with parsed data parser.write_to_dataset(dset) Description: Reads GNSS ephemeris data from RINEX navigation file in format 2.11 (see :cite: rinex2 ) or 3.03 (see :cite: rinex3 ). get_rinex2_or_rinex3 () Full name: midgard.parsers.rinex_nav.get_rinex2_or_rinex3 Signature: (file_path: pathlib.PosixPath) -> 'TODO' Use either Rinex2NavParser or Rinex3NavParser for reading orbit files in format 2.11 or 3.03. Firstly the RINEX file version is read. Based on the read version number it is decided, which Parser should be used. Args: file_path (pathlib.PosixPath): File path to broadcast orbit file. midgard.parsers.slr_prediction A parser for reading SLR prediction files Description: Reads data from files in the CPF file format as defined in http://ilrs.gsfc.nasa.gov/docs/2006/cpf_1.01.pdf SlrPredictionParser Full name: midgard.parsers.slr_prediction.SlrPredictionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading SLR prediction files (CPF format) midgard.parsers.spring_csv A parser for reading Spring CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='spring_csv', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in Spring CSV output format. The header information of the Spring CSV file is not read (TODO). SpringCsvParser Full name: midgard.parsers.spring_csv.SpringCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Spring CSV output files The Spring CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the Spring CSV colum values. Depending on the Spring CSV following dataset fields can be available: Field Description acquiredsat Number of acquired satellites (TODO?) gdop Geometric dilution of precision hdop Horizontal dilution of precision pdop Position (3D) dilution of precision satinview Number of satellites in view system GNSS identifier based on RINEX definition (e.g. G: GPS, E: Galileo) tdop Time dilution of precision time Observation time given as Time object usedsat Number of used satellites vdop Vertical dilution of precision ... ... midgard.parsers.terrapos_position A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format. TerraposPositionParser Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.terrapos_residual A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format. TerraposResidualParser Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name midgard.parsers.ure_control_tool_csv A parser for reading URE Control Tool CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='ure_control_tool_csv', file_path='G_GAL258_E1E5a_URE-AllPRN_190301.csv') data = p.as_dict() Description: Reads data from files in URE Control Tool CSV output format. The header information of the URE Control Tool CSV file is not read (TODO). UreControlToolCsvParser Full name: midgard.parsers.ure_control_tool_csv.UreControlToolCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading URE Control Tool CSV output files The URE Control Tool CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the URE Control Tool CSV colum values. midgard.parsers.vlbi_source_names A parser for reading IVS source names translation table VlbiSourceNamesParser Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file midgard.parsers.wip_rinex A parser for reading Rinex files rinex () Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type midgard.parsers.wip_rinex2_nav A parser for reading RINEX navigation files with version 2.xx Rinex2NavParser Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 2.xx midgard.parsers.wip_rinex2_nav_header RINEX navigation header classes for file format version 2.xx Rinex2NavHeaderMixin Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx Rinex2NavHeaderParser Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex2_obs A parser for reading RINEX observation files with version 2.xx Rinex2ObsParser Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 2.xx midgard.parsers.wip_rinex2_obs_header RINEX observation header classes for file format version 3.xx Rinex2ObsHeaderMixin Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx Rinex2ObsHeaderParser Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_clk A parser for reading RINEX clock files with version 3.xx Rinex3ClkParser Full name: midgard.parsers.wip_rinex3_clk.Rinex3ClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX clock files with version 3.xx midgard.parsers.wip_rinex3_clk_header RINEX clock header classes for file format version 3.xx Rinex3ClkHeaderMixin Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx Rinex3ClkHeaderParser Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_nav A parser for reading RINEX navigation files with version 3.xx Rinex3NavParser Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 3.xx midgard.parsers.wip_rinex3_nav_header RINEX navigation header classes for file format version 3.xx Rinex3NavHeaderMixin Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx Rinex3NavHeaderParser Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex3_obs A parser for reading RINEX observation files with version 3.xx Rinex3ObsParser Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 3.xx midgard.parsers.wip_rinex3_obs_header RINEX observation header classes for file format version 3.xx Rinex3ObsHeaderMixin Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx Rinex3ObsHeaderParser Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed. midgard.parsers.wip_rinex_clk A parser for reading Rinex navigation files RinexClkParser Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX clock parsers. rinex_clk () Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_nav A parser for reading Rinex navigation files RinexNavParser Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX navigation parsers. rinex_nav () Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file midgard.parsers.wip_rinex_obs A parser for reading Rinex observation files RinexObsParser Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX observation parsers. rinex_obs () Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"midgard.parsers"},{"location":"api/midgard-parsers/#midgardparsers","text":"Framework for parsers Description: To add a new parser, simply create a new .py-file which defines a class inheriting from parsers.Parser. The class needs to be decorated with the midgard.dev.plugins.register decorator as follows: from midgard.parsers import parser from midgard.lib import plugins @plugins.register class MyNewParser(parser.Parser): ... To use a parser, you will typically use the parse_file -function defined below from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict() The name used in parse_file to call the parser is the name of the module (file) containing the parser.","title":"midgard.parsers"},{"location":"api/midgard-parsers/#names","text":"Full name: midgard.parsers.names Signature: () -> List[str] List the names of the available parsers Returns: Names of the available parsers","title":"names()"},{"location":"api/midgard-parsers/#parse_file","text":"Full name: midgard.parsers.parse_file Signature: (parser_name: str, file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, timer_logger: Union[Callable[[str], NoneType], NoneType] = None, use_cache: bool = False, **parser_args: Any) -> midgard.parsers._parser.Parser Use the given parser on a file and return parsed data Specify parser_name and file_path to the file that should be parsed. The following parsers are available: {doc_parser_names} Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods as_dict , as_dataframe or as_dataset . Example: >>> df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe() # doctest: +SKIP Args: parser_name : Name of parser file_path : Path to file that should be parsed. encoding : Encoding in file that is parsed. timer_logger : Logging function that will be used to log timing information. use_cache : Whether to use a cache to avoid parsing the same file several times. (TODO: implement this) parser_args : Input arguments to the parser Returns: Parser : Parser with the parsed data","title":"parse_file()"},{"location":"api/midgard-parsers/#midgardparsers_parser","text":"Basic functionality for parsing datafiles, extended by individual parsers Description: This module contains functions and classes for parsing datafiles. It should typically be used by calling parsers.parse_file : Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser"},{"location":"api/midgard-parsers/#parser","text":"Full name: midgard.parsers._parser.Parser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for instance ChainParser, LineParser, SinexParser etc Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...).","title":"Parser"},{"location":"api/midgard-parsers/#midgardparsers_parser_chain","text":"Basic functionality for parsing datafiles line by line Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_chain"},{"location":"api/midgard-parsers/#chainparser","text":"Full name: midgard.parsers._parser_chain.ChainParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for parsing a file with chained groups of information. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"ChainParser"},{"location":"api/midgard-parsers/#parserdef","text":"Full name: midgard.parsers._parser_chain.ParserDef Signature: (end_marker: Callable[[str, int, str], bool], label: Callable[[str, int], Any], parser_def: Dict[Any, Dict[str, Any]], skip_line: Union[Callable[[str], bool], NoneType] = None, end_callback: Union[Callable[[Dict[str, Any]], NoneType], NoneType] = None) A convenience class for defining the necessary fields of a parser A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines (end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback). The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures: end_marker = func(line, line_num, next_line) label = func(line, line_num) skip_line = func(line) end_callback = func(cache) The parser definition parser_def includes the parser , field , strip and delimiter entries. The parser entry points to the parser function and the field entry defines how to separate the line in fields. The separated fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by default. With the delimiter entry the default definition can be overwritten. Leading and trailing whitespace characters are removed by default before a line is parsed. This default can be overwritten by defining the characters, which should be removed with the 'strip' entry. The parser dictionary is defined like: parser_def = { <label>: {'fields': <dict or list of fields>, 'parser': <parser function>, 'delimiter': <optional delimiter for splitting line>, 'strip': <optional characters to be removed from beginning and end of line> }} Args: end_marker : A function returning True for the last line in a group. label : A function returning a label used in the parser_def. parser_def : A dict with 'parser' and 'fields' defining the parser. skip_line : A function returning True if the line should be skipped. end_callback : A function called after reading all lines in a group.","title":"ParserDef"},{"location":"api/midgard-parsers/#midgardparsers_parser_line","text":"Basic functionality for parsing datafiles line by line using Numpy Description: This module contains functions and classes for parsing datafiles. Example: from midgard import parsers my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...) my_data = my_new_parser.as_dict()","title":"midgard.parsers._parser_line"},{"location":"api/midgard-parsers/#lineparser","text":"Full name: midgard.parsers._parser_line.LineParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for using numpy to parse a file line by line. You should inherit from this one, and at least specify the necessary parameters in setup_parser .","title":"LineParser"},{"location":"api/midgard-parsers/#midgardparsers_parser_rinex","text":"Basic functionality for parsing Rinex files Description: This module contains functions and classes for parsing Rinex files. This file defines the general structure shared by most types of Rinex files, including header information. More specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser for a given Rinex format.","title":"midgard.parsers._parser_rinex"},{"location":"api/midgard-parsers/#rinexheader","text":"Full name: midgard.parsers._parser_rinex.RinexHeader Signature: (marker: str, fields: Dict[str, Tuple[int, int]], parser: Callable[[Dict[str, str]], Dict[str, Any]]) A convenience class for defining how a Rinex header is parsed Args: marker : Marker of header (as defined in columns 60 and onward). fields : Dictionary with field names as keys, tuple of start- and end-columns as value. parser : Function that will parse the fields.","title":"RinexHeader"},{"location":"api/midgard-parsers/#rinexparser","text":"Full name: midgard.parsers._parser_rinex.RinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None An abstract base class that has basic methods for parsing a datafile This class provides functionality for reading Rinex header data. You should inherit from this one, and at least implement parse_epochs .","title":"RinexParser"},{"location":"api/midgard-parsers/#parser_cache","text":"Full name: midgard.parsers._parser_rinex.parser_cache Signature: (func: Callable[[ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -> Callable[[ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]] Decorator for adding a cache to parser functions","title":"parser_cache()"},{"location":"api/midgard-parsers/#midgardparsers_parser_sinex","text":"Basic functionality for parsing Sinex datafiles Description: This module contains functions and classes for parsing Sinex datafiles. References: SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html","title":"midgard.parsers._parser_sinex"},{"location":"api/midgard-parsers/#sinexblock","text":"Full name: midgard.parsers._parser_sinex.SinexBlock Signature: (marker: str, fields: Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser: Callable[[<built-in function array>, Tuple[str, ...]], Dict[str, Any]]) A convenience class for defining a Sinex block Args: marker : Sinex marker denoting the block. fields : Fields in Sinex block. parser : Function used to parse the data.","title":"SinexBlock"},{"location":"api/midgard-parsers/#sinexfield","text":"Full name: midgard.parsers._parser_sinex.SinexField Signature: (name: str, start_col: int, dtype: Union[str, NoneType], converter: Union[str, NoneType] = None) A convenience class for defining the fields in a Sinex block Args: name : Name of field. start_col : Starting column of field (First column is 0) dtype : String, using numpy notation, defining type of field, use None to ignore field. converter : Optional, name of converter to apply to field data.","title":"SinexField"},{"location":"api/midgard-parsers/#sinexparser","text":"Full name: midgard.parsers._parser_sinex.SinexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None An abstract base class that has basic methods for parsing a Sinex file This class provides functionality for parsing a sinex file with chained groups of information. You should inherit from this one, and at least specify which Sinex blocks you are interested in by implementing setup_parser , as well as implement methods that parse each block if needed.","title":"SinexParser"},{"location":"api/midgard-parsers/#parsing_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_factory Signature: () -> Callable[..., Dict[str, Any]] Create a default parsing function for a Sinex block The default parsing function returns a dictionary containing all fields of the block as separated arrays. This will be stored in self.data['{marker}'] with the {marker} of the current block. Returns: Simple parsing function for one Sinex block.","title":"parsing_factory()"},{"location":"api/midgard-parsers/#parsing_matrix_factory","text":"Full name: midgard.parsers._parser_sinex.parsing_matrix_factory Signature: (marker: str, size_marker: str) -> Callable[..., Dict[str, Any]] Create a parsing function for parsing a matrix within a Sinex block The default parsing function converts data to a symmetric matrix and stores it inside self.data[marker] . The size of the matrix is set to equal the number of parameters in the size_marker -block. If that block is not parsed/found. The size is set to the last given row index. If some zero elements in the matrix are omitted this might be wrong. Args: marker : Marker of Sinex block. size_marker : Marker of a different Sinex block indicating the size of the matrix. Returns: Simple parsing function for one Sinex block.","title":"parsing_matrix_factory()"},{"location":"api/midgard-parsers/#midgardparsersanubis","text":"A parser for reading Anubis xtr-files","title":"midgard.parsers.anubis"},{"location":"api/midgard-parsers/#anubisxtrparser","text":"Full name: midgard.parsers.anubis.AnubisXtrParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Anubis XTR files","title":"AnubisXtrParser"},{"location":"api/midgard-parsers/#midgardparsersbcecmp_sisre","text":"A parser for reading DLR BCEcmp Software SISRE output files Example: from midgard import parsers p = parsers.parse_file(parser_name='bcecmp_sisre', file_path='BCEcmp_GAL_FNAV_E1E5A_com_2018_032.OUT') data = p.as_dict() Description: Reads data from files in the BCEcmp Software output file format. The BCEcmp Software is developed and used by DLR.","title":"midgard.parsers.bcecmp_sisre"},{"location":"api/midgard-parsers/#bcecmpparser","text":"Full name: midgard.parsers.bcecmp_sisre.BcecmpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading DLR BCEcmp Software output files. The following data are available after reading BCEcmp Software output file: Key Description age_min age of ephemeris in [min] clk_diff_with_dt_mean Satellite clock correction difference corrected for average satellite clock offset difference for given GNSS and epoch in [m] dalong_track Along-track orbit difference in [m] dcross_track Cross-track orbit difference in [m] dradial Radial orbit difference in [m] dradial_wul Worst-user-location (wul) SISRE? satellite Satellite PRN number together with GNSS identifier (e.g. G07) sisre Signal-in-space range error [m] time Observation time used_iodc GPS: IODC (Clock issue of data indicates changes (set equal to IODE)) QZSS: IODC used_iode Ephemeris issue of data indicates changes to the broadcast ephemeris: - GPS: Ephemeris issue of data (IODE), which is set equal to IODC - Galileo: Issue of Data of the NAV batch (IODnav) - QZSS: Ephemeris issue of data (IODE) - BeiDou: Age of Data Ephemeris (AODE) - IRNSS: Issue of Data, Ephemeris and Clock (IODEC) and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"BcecmpParser"},{"location":"api/midgard-parsers/#midgardparserscsv_","text":"A parser for reading CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='csv_', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in CSV output format. The header information of the CSV file is not read (TODO).","title":"midgard.parsers.csv_"},{"location":"api/midgard-parsers/#csvparser","text":"Full name: midgard.parsers.csv_.CsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading CSV output files The CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the CSV colum values. Following meta -data are available after reading of CSV file: Key Description __data_path__ File path __parser_name__ Parser name","title":"CsvParser"},{"location":"api/midgard-parsers/#midgardparsersdiscontinuities_snx","text":"A parser for reading data from discontinuities.snx in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='discontinuities_snx', file_path='discontinuities_snx') data = p.as_dict() Description: Reads discontinuities of GNSS station timeseries in SINEX format .","title":"midgard.parsers.discontinuities_snx"},{"location":"api/midgard-parsers/#discontinuitiessnxparser","text":"Full name: midgard.parsers.discontinuities_snx.DiscontinuitiesSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None A parser for reading data from discontinuties.snx file in SINEX format The solution discontinuity dictionary has as keys the site identifiers and as value the 'solution_discontinuity' entry. The dictionary has following strucuture: self.data[site] = { 'solution_discontinuity': [] } # SOLUTION/DISCONTINUITY SINEX block information with the 'solution_discontinuity' dictionary entries solution_discontinuity[ii] = [ 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'event_code': event_code, 'description': description ] The counter 'ii' ranges from 0 to n and depends on how many discontinuities exists for a site. Note also, that time entries (e.g. start_time, end_time) are given as 'datetime'. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"DiscontinuitiesSnxParser"},{"location":"api/midgard-parsers/#midgardparsersgalileo_constellation_html","text":"A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"midgard.parsers.galileo_constellation_html"},{"location":"api/midgard-parsers/#galileoconstellationhtmlparser","text":"Full name: midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, url: Union[str, NoneType] = None) -> None A parser for reading Galileo constellation info from a web page See https://www.gsc-europa.eu/system-status/Constellation-Information for an example","title":"GalileoConstellationHTMLParser"},{"location":"api/midgard-parsers/#midgardparsersgipsy_tdp","text":"A parser for reading NASA JPL Gipsy time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsy_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in Gipsy time dependent parameter (TDP) format.","title":"midgard.parsers.gipsy_tdp"},{"location":"api/midgard-parsers/#gipsytdpparser","text":"Full name: midgard.parsers.gipsy_tdp.GipsyTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Gipsy time dependent parameter (TDP) file Following data are available after reading Gipsy TDP output file: Key Description apriori_value Nominal value. This field contains the last value used by the model. name Parameter name. sigma The sigma associated with the value of the parameter. A negative value indicates it should be used for interpolation by the file reader read_time_variation in $GOA/libsrc/time_variation. If no sigmas are computed by the smapper, a 1.0 will be placed here. time_past_j2000 Time given in GPS seconds past J2000. value Accumulated value of the parameter at time and includes any nominal, or iterative correction. This is the only entry used by the model. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyTdpParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_gdcov","text":"A parser for reading NASA JPL GipsyX gdcov format file gdcov format file includes GipsyX estimates and covariance information. NOTE: At the moment this parser can only read station estimate and covariance information, that means STA.X, STA.Y and STA.Z parameters. Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_gdcov', file_path='smoothFinal.gdcov') data = p.as_dict() Description: Reads data from files in GipsyX gdcov format.","title":"midgard.parsers.gipsyx_gdcov"},{"location":"api/midgard-parsers/#gipsyxgdcovparser","text":"Full name: midgard.parsers.gipsyx_gdcov.GipsyxGdcovParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX gdcov format file Following data are available after reading GipsyX gdcov output file: Key Description column Column number of correlations correlation Correlation values parameter Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. row Row number of correlations station Station name. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. estimate Parameter estimate at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxGdcovParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_residual","text":"A parser for reading NASA JPL GipsyX residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_residual', file_path='finalResiduals.out') data = p.as_dict() Description: Reads data from files in GipsyX residual format.","title":"midgard.parsers.gipsyx_residual"},{"location":"api/midgard-parsers/#gipsyxresidualparser","text":"Full name: midgard.parsers.gipsyx_residual.GipsyxResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX residual file Following data are available after reading GipsyX residual output file: Key Description azimuth Azimuth from receiver azimuth_sat Azimuth from satellite data_type Data type (e.g. IonoFreeC_1P_2P, IonoFreeL_1P_2P) deleted Residuals are deleted, marked with True or False. elevation Elevation from receiver elevation_sat Elevation from satellite residual Post-fit residual satellite Satellite name station Station name time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxResidualParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_series","text":"A parser for reading NASA JPL GipsyX timeseries file Example: from analyx import parsers p = parsers.parse_file(parser_name='gipsyx_series', file_path='NYA1.series') data = p.as_dict() Description: Reads data from files in GipsyX timeseries format.","title":"midgard.parsers.gipsyx_series"},{"location":"api/midgard-parsers/#gipsyxseriesparser","text":"Full name: midgard.parsers.gipsyx_series.GipsyxSeriesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX timeseries file Following data are available after reading GipsyX residual output file: Key Description corr_en Correlation East-North. corr_ev Correlation East-Vertical. corr_nv Correlation North-Vertical. day Day decimalyear Date in unit year. east East coordinate in [m]. east_sigma Standard devication of east coordinate in [m]. hour Hour minute Minute month Month north North coordinate in [m]. north_sigma Standard devication of north coordinate in [m]. second Second time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. vertical Vertical coordinate in [m]. vertical_sigma Standard devication of vertical coordinate in [m]. year Year and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxSeriesParser"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_summary","text":"A parser for reading GipsyX summary output file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_summary', file_path='gipsyx_summary') data = p.as_dict() Description: Reads data from files in GipsyX summary output format.","title":"midgard.parsers.gipsyx_summary"},{"location":"api/midgard-parsers/#gipsyxsummary","text":"Full name: midgard.parsers.gipsyx_summary.GipsyxSummary Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX summary file GipsyX summary file data are grouped as follows: Key Description position Dictionary with position summary information residual Dictionary with residual summary information station Station name position entries are: Key Description pos_x X-coordinate of station position solution pos_y Y-coordinate of station position solution pos_z Z-coordinate of station position solution pos_vs_ref_x X-coordinate of difference between solution and reference of station coordinate pos_vs_ref_y Y-coordinate of difference between solution and reference of station coordinate pos_vs_ref_z Z-coordinate of difference between solution and reference of station coordinate pos_vs_ref_e East-coordinate of difference between solution and reference of station coordinate pos_vs_ref_n North-coordinate of difference between solution and reference of station coordinate pos_vs_ref_v Vertical-coordinate of difference between solution and reference of station coordinate residual entries are: Key Description code_max Maximal residual of used pseudo-range observations code_min Minimal residual of used pseudo-range observations code_num Number of used pseudo-range observations code_rms RMS of residuals from used pseudo-range observations code_outlier_max Maximal residual of rejected pseudo-range observations code_outlier_min Minimal residual of rejected pseudo-range observations code_outlier_num Number of rejected pseudo-range observations code_outlier_rms RMS of residuals from rejected pseudo-range observations phase_max Maximal residual of used phase observations phase_min Minimal residual of used phase observations phase_num Number of used phase observations phase_rms RMS of residuals from used phase observations phase_outlier_max Maximal residual of rejected phase observations phase_outlier_min Minimal residual of rejected phase observations phase_outlier_num Number of rejected phase observations phase_outlier_rms RMS of residuals from rejected phase observations and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxSummary"},{"location":"api/midgard-parsers/#midgardparsersgipsyx_tdp","text":"A parser for reading NASA JPL GipsyX time dependent parameter (TDP) file Example: from midgard import parsers p = parsers.parse_file(parser_name='gipsyx_tdp', file_path='final.tdp') data = p.as_dict() Description: Reads data from files in GipsyX time dependent parameter (TDP) format.","title":"midgard.parsers.gipsyx_tdp"},{"location":"api/midgard-parsers/#datasetfield","text":"Full name: midgard.parsers.gipsyx_tdp.DatasetField Signature: (name=None, category=None, dtype=None) A convenience class for defining a dataset field properties Args: name (str): Dataset field name category (str): Category of parameter (e.g. station or satellite parameter) dtype (str): Dataset data type","title":"DatasetField"},{"location":"api/midgard-parsers/#gipsyxtdpparser","text":"Full name: midgard.parsers.gipsyx_tdp.GipsyxTdpParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GipsyX time dependent parameter (TDP) file Following data are available after reading GipsyX TDP output file: Key Description apriori Nominal value. This field contains the last value used by the model. name Parameter name. An arbitrary sequence of letters [A-Z,a-z], digits[0-9], and \".\" without spaces. sigma Standard deviation of the parameter. time_past_j2000 Time given in GPS seconds past J2000, whereby GipsyX uses following definition: J2000 is continuous seconds past Jan. 1, 2000 11:59:47 UTC. value Parameter value at the given time and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GipsyxTdpParser"},{"location":"api/midgard-parsers/#midgardparsersglab_output","text":"A parser for reading gLAB output files Example: from midgard import parsers p = parsers.parse_file(parser_name='glab_output', file_path='glab_output.txt') data = p.as_dict() Description:","title":"midgard.parsers.glab_output"},{"location":"api/midgard-parsers/#glaboutputparser","text":"Full name: midgard.parsers.glab_output.GlabOutputParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading gLAB output files The keys of the data dictionary are defined depending, which kind of gLAB output file is read. The values of the data dictionary are represented by the gLAB colum values. Following meta -data are available after reading of gLAB files: Key Description __data_path__ File path __parser_name__ Parser name","title":"GlabOutputParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_android_raw_data","text":"A parser for reading GNSS raw data from GnssLogger Android App Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"gnss_android_raw_data\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads raw data file from GnssLogger Android App.","title":"midgard.parsers.gnss_android_raw_data"},{"location":"api/midgard-parsers/#gnssandroidrawdataparser","text":"Full name: midgard.parsers.gnss_android_raw_data.GnssAndroidRawDataParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None","title":"GnssAndroidRawDataParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_antex","text":"A parser for reading ANTEX format 1.4 data Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx') data = p.as_dict() Description: Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite: antex ).","title":"midgard.parsers.gnss_antex"},{"location":"api/midgard-parsers/#antexparser","text":"Full name: midgard.parsers.gnss_antex.AntexParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading ANTEX file The parser reads GNSS ANTEX format 1.4 (see :cite: antex ). The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite antenna corrections are time dependent and saved with \"valid from\" datetime object entry. The dictionary looks like: dout = { <prn> : { <valid from>: { cospar_id: <value>, sat_code: <value>, sat_type: <value>, valid_until: <value>, azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<list with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}}, <receiver antenna> : { azimuth: <list with azimuth values>, elevation: <list with elevation values>, <frequency>: { azi: [<array with azimuth-elevation dependent corrections>], neu: [north, east, up], noazi: [<list with elevation dependent corrections>] }}} with following entries: Value Type Description azi numpy.ndarray Array with azimuth-elevation dependent antenna correction in [mm] with the shape: number of azimuth values x number of elevation values. azimuth numpy.ndarray List with azimuth values in [rad] corresponding to antenna corrections given in azi . cospar_id str COSPAR ID : yyyy -> year when the satellite was put in orbit, xxx -> sequential satellite number for that year, a -> alpha numeric sequence number within a launch elevation numpy.ndarray List with elevation values in [rad] corresponding to antenna corrections given in azi or noazi . str Frequency identifier (e.g. G01 - GPS L1) neu list North, East and Up eccentricities in [m]. The eccentricities of the mean antenna phase center is given relative to the antenna reference point (ARP) for receiver antennas or to the center of mass of the satellite in X-, Y- and Z-direction. noazi numpy.ndarray List with elevation dependent (non-azimuth-dependent) antenna correction in [mm]. str Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number str Receiver antenna name together with radome code sat_code str Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number sat_type str Satellite type (e.g. BLOCK IIA) valid_from datetime.datetime Start of validity period of satellite in GPS time valid_until datetime.datetime End of validity period of satellite in GPS time The 'meta' attribute is a dictionary with following entries: Value Type Description comment list Header commments given in list line by line pcv_type str Phase center variation type ref_antenna str Reference antenna type for relative antenna ref_serial_num str Serial number of the reference antenna sat_sys str Satellite system version str Format version Attributes: data : (dict), Contains the (observation) data read from file. data_available : (bool), Indicator of whether data are available. file_path : (pathlib.Path), File path. parser_name : (str), Parser name. meta : (dict), Contains metainformation read from file.","title":"AntexParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_bernese_crd","text":"A parser for reading Bernese CRD file Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_bernese_crd', file_path='W20216.CRD') data = p.as_dict() Description: Reads data from files in Bernese CRD format.","title":"midgard.parsers.gnss_bernese_crd"},{"location":"api/midgard-parsers/#gnsscrdparser","text":"Full name: midgard.parsers.gnss_bernese_crd.GnssCrdParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Bernese CRD file Following data are available after reading Bernese CRD file: Parameter Description num Number of station coordinate solution station 4-digit station identifier domes Domes number gpssec Seconds of GPS week pos_x X-coordinate of station position pos_y Y-coordinate of station position pos_z Z-coordinate of station position flag Flag and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"GnssCrdParser"},{"location":"api/midgard-parsers/#midgardparsersgnss_galat_results","text":"A parser for GALAT single point positioning result files Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_galat_results', file_path='galat_results.txt') data = p.as_dict() Description: Reads data from files in GALAT result format.","title":"midgard.parsers.gnss_galat_results"},{"location":"api/midgard-parsers/#galatresults","text":"Full name: midgard.parsers.gnss_galat_results.GalatResults Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading GALAT single point positioning result files Following data are available after reading GALAT SPP result file: Key Description time Time epoch latitude Latitude in degree longitude Longitude in degree height Height in [m] dlatitude Latitude related to reference coordinate in [m] dlongitude Longitude related to reference coordinate in [m] dheight Height related to reference coordinate in [m] hpe Horizontal positioning error (HPE) in [m] vpe Vertical positioning error (VPE) in [m] site_vel_3d 3D site velocity in [m/s] pdop Precision dilution of precision num_satellite_available Number of available satellites num_satellite_used Number of used satellites and meta -data: Key Description __data_path__ File path __params__ np.genfromtxt parameters __parser_name__ Parser name","title":"GalatResults"},{"location":"api/midgard-parsers/#midgardparsersgnss_sinex_igs","text":"A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format Example: from midgard import parsers p = parsers.parse_file(parser_name='gnss_sinex_igs', file_path='igs.snx') data = p.as_dict() Description: Reads station information (e.g. approximated station coordinates, receiver and antenna type, station eccentricities, ...) igs.snx file in SINEX format.","title":"midgard.parsers.gnss_sinex_igs"},{"location":"api/midgard-parsers/#igssnxparser","text":"Full name: midgard.parsers.gnss_sinex_igs.IgsSnxParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, header: bool = True) -> None A parser for reading data from igs.snx file based on IGS sitelog files in SINEX format site - Site dictionary, whereby keys are the site identifiers and values are a site entry dictionary with the keys 'site_antenna', 'site_eccentricity', 'site_id' and 'site_receiver'. The site dictionary has following strucuture: self.site[site] = { 'site_antenna': [], # SITE/ANTENNA SINEX block information 'site_eccentricity': [], # SITE/ECCENTRICITY block information 'site_id': {}, # SITE/ID block information 'site_receiver': [], # SITE/RECEIVER block information } with the site entry dictionary entries site_antenna[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'antenna_type': antenna_type, 'radome_type': radome_type, 'serial_number': serial_number } site_eccentricity[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'reference_system': reference_system, 'vector_1': vector_1, 'vector_2': vector_2, 'vector_3': vector_3, 'vector_type': UNE } site_id = { 'point_code': point_code, 'domes': domes, 'marker': marker, 'obs_code': obs_code, 'description': description, 'approx_lon': approx_lon, 'approx_lat': approx_lat, 'approx_height': approx_height } site_receiver[ii] = { 'point_code': point_code, 'soln': soln, 'obs_code': obs_code, 'start_time': start_time, 'end_time': end_time, 'receiver_type': receiver_type, 'serial_number': serial_number, 'firmware': firmware } The counter 'ii' ranges from 0 to n and depends on how many antenna type, receiver type and antenna monument changes were done at each site. Note also, that time entries (e.g. start_time, end_time) are given in Modified Julian Date. If the time is defined as 00:000:00000 in the SINEX file, then the value is saved as 'None' in the Sinex class.","title":"IgsSnxParser"},{"location":"api/midgard-parsers/#midgardparsersrinex212_nav","text":"A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex212_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.12 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.12. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ).","title":"midgard.parsers.rinex212_nav"},{"location":"api/midgard-parsers/#rinex212navparser","text":"Full name: midgard.parsers.rinex212_nav.Rinex212NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.12 (see :cite: rinex2 ).","title":"Rinex212NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_file_extension-dict","text":"SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'}","title":"SYSTEM_FILE_EXTENSION (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex2_nav","text":"A parser for reading GNSS RINEX navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 2.11 (see :cite: rinex2 ). An exception is, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale. The navigation message is not defined for GALILEO, BeiDou, QZSS and IRNSS in RINEX format 2.11. In this case the RINEX 3.03 definition is used (see :cite: rinex3 ).","title":"midgard.parsers.rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser","text":"Full name: midgard.parsers.rinex2_nav.Rinex2NavParser Signature: (*args: Tuple[Any], **kwargs: Dict[Any, Any]) A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 2.11 (see :cite: rinex2 ).","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables_1","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _get_system_from_file_extension() Get GNSS by reading RINEX navigation file extension _parse_file() Read a data file and parse the content _parse_ion_alpha() Parse entries of RINEX header `ION ALPHA` to instance variable `meta`. _parse_ion_beta() Parse entries of RINEX header `ION BETA` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `DELTA-UTC: A0,A1,T,W` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict_1","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_file_extension-dict_1","text":"SYSTEM_FILE_EXTENSION = {'n': 'G', 'g': 'R', 'l': 'E'}","title":"SYSTEM_FILE_EXTENSION (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex2_obs","text":"A parser for reading Rinex data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex2_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the Rinex file format 2.11 (see :cite: rinex2 ).","title":"midgard.parsers.rinex2_obs"},{"location":"api/midgard-parsers/#rinex2parser","text":"Full name: midgard.parsers.rinex2_obs.Rinex2Parser Signature: (*args: Tuple[Any], sampling_rate: Union[NoneType, float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 2.11 (see :cite: rinex2 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. system (String): GNSS identifier. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition.","title":"Rinex2Parser"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_time-dict","text":"SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex3_nav","text":"A parser for reading GNSS RINEX v3.03 navigation file (exception GLONASS and SBAS) Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_nav\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads GNSS data from files in the RINEX navigation file format 3.03 (see :cite: rinex3 ). An exception is also, that this parser does not handle GLONASS and SBAS navigation messages. All navigation time epochs (time of clock (toc)) are converted to GPS time scale.","title":"midgard.parsers.rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser","text":"Full name: midgard.parsers.rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading RINEX navigation file The parser reads GNSS broadcast ephemeris in RINEX format 3.03 (see :cite: rinex3 ) except for GLONASS and SBAS.","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#todo-would-it-not-be-better-to-use-one-leading-underscore-for-non-public-methods-and-instance-variables_2","text":"Attributes: data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). system (String): GNSS identifier. Methods: as_dataframe() Return the parsed data as a Pandas DataFrame as_dataset() Return the parsed data as a Midgard Dataset as_dict() Return the parsed data as a dictionary parse() Parse data parse_line() Parse line postprocess_data() Do simple manipulations on the data after they are read read_data() Read data from the data file setup_parser() Set up information needed for the parser setup_postprocessors() List postprocessors that should be called after parsing _check_nav_message() Check correctness of navigation message _parse_file() Read a data file and parse the content _parse_ionospheric_corr() Parse entries of RINEX header `IONOSPHERIC CORR` to instance variable `meta`. _parse_leap_seconds() Parse entries of RINEX header `LEAP SECONDS` to instance variable `meta`. _parse_obs_float() Parse float entries of RINEX navigation data block to instance variable 'data'. _parse_observation_epoch() Parse observation epoch information of RINEX navigation data record _parse_string() Parse string entries of SP3 header to instance variable 'meta' _parse_string_list() Parse string entries of RINEX header to instance variable 'meta' in a list _parse_time_system_corr() Parse entries of RINEX header `TIME SYSTEM CORR` to instance variable `meta`. _rename_fields_based_on_system() Rename general GNSS fields to GNSS specific ones _time_system_correction() Apply correction to given time system for getting GPS time scale","title":"TODO: Would it not be better to use one leading underscore for non-public methods and instance variables."},{"location":"api/midgard-parsers/#sysnames-dict_2","text":"SYSNAMES = {'gnss_data_info': {'G': 'codes_l2', 'J': 'codes_l2', 'E': 'data_source'}, 'gnss_interval': {'G': 'fit_interval', 'J': 'fit_interval', 'C': 'age_of_clock_corr'}, 'gnss_iodc_groupdelay': {'G': 'iodc', 'J': 'iodc', 'E': 'bgd_e1_e5b', 'C': 'tgd_b2_b3'}, 'gnss_l2p_flag': {'G': 'l2p_flag', 'J': 'l2p_flag'}, 'gnss_tgd_bgd': {'G': 'tgd', 'J': 'tgd', 'E': 'bgd_e1_e5a', 'C': 'tgd_b1_b3', 'I': 'tgd'}}","title":"SYSNAMES (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_second-dict_2","text":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND = {'C': 14, 'E': 0, 'G': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_SECOND (dict)"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_week-dict_2","text":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK = {'C': 1356, 'E': 0, 'G': 0, 'I': 0, 'J': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_WEEK (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex3_obs","text":"A parser for reading RINEX format 3.03 data Example: from midgard import parsers # Parse data parser = parsers.parse_file(parser_name=\"rinex3_obs\", file_path=file_path) # Get Dataset with parsed data dset = parser.as_dataset() Description: Reads data from files in the RINEX file format version 3.03 (see :cite: rinex3 ).","title":"midgard.parsers.rinex3_obs"},{"location":"api/midgard-parsers/#rinex3parser","text":"Full name: midgard.parsers.rinex3_obs.Rinex3Parser Signature: (*args: Tuple[Any], sampling_rate: Union[NoneType, float] = None, convert_unit: bool = False, **kwargs: Dict[Any, Any]) -> None A parser for reading RINEX observation file The parser reads GNSS observations in RINEX format 3.03 (see :cite: rinex3 ). The GNSS observations are sampled after sampling rate definition in configuration file. Attributes: convert_unit (Boolean): Convert unit from carrier-phase and Doppler observation to meter. Exception: unit conversion for GLONASS observations is not implemented. data (Dict): The (observation) data read from file. data_available (Boolean): Indicator of whether data are available. file_encoding (String): Encoding of the datafile. file_path (Path): Path to the datafile that will be read. meta (Dict): Metainformation read from file. parser_name (String): Name of the parser (as needed to call parsers.parse_...). sampling_rate (Float): Sampling rate in seconds. time_scale (String): Time scale, which is used to define the time scale of Dataset. GPS time scale is used. If another time scale is given e.g. BDT, then the time entries are converted to GPS time scale. An exception is if GLONASS time scale is given, then UTC is used as time scale. Hereby should be noted, the reported GLONASS time has the same hours as UTC and not UTC+3 h as the original GLONASS System Time in the RINEX file definition. system (String): GNSS identifier.","title":"Rinex3Parser"},{"location":"api/midgard-parsers/#system_time_offset_to_gps_time-dict_1","text":"SYSTEM_TIME_OFFSET_TO_GPS_TIME = {'BDT': 14, 'GAL': 0, 'IRN': 0, 'QZS': 0}","title":"SYSTEM_TIME_OFFSET_TO_GPS_TIME (dict)"},{"location":"api/midgard-parsers/#midgardparsersrinex_nav","text":"A parser for reading GNSS RINEX navigation files Example: from midgard.data import dataset from midgard import parsers # Parse data parser = parsers.parse(file_path=file_path) # Create a empty Dataset dset = data.Dataset() # Fill Dataset with parsed data parser.write_to_dataset(dset) Description: Reads GNSS ephemeris data from RINEX navigation file in format 2.11 (see :cite: rinex2 ) or 3.03 (see :cite: rinex3 ).","title":"midgard.parsers.rinex_nav"},{"location":"api/midgard-parsers/#get_rinex2_or_rinex3","text":"Full name: midgard.parsers.rinex_nav.get_rinex2_or_rinex3 Signature: (file_path: pathlib.PosixPath) -> 'TODO' Use either Rinex2NavParser or Rinex3NavParser for reading orbit files in format 2.11 or 3.03. Firstly the RINEX file version is read. Based on the read version number it is decided, which Parser should be used. Args: file_path (pathlib.PosixPath): File path to broadcast orbit file.","title":"get_rinex2_or_rinex3()"},{"location":"api/midgard-parsers/#midgardparsersslr_prediction","text":"A parser for reading SLR prediction files Description: Reads data from files in the CPF file format as defined in http://ilrs.gsfc.nasa.gov/docs/2006/cpf_1.01.pdf","title":"midgard.parsers.slr_prediction"},{"location":"api/midgard-parsers/#slrpredictionparser","text":"Full name: midgard.parsers.slr_prediction.SlrPredictionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading SLR prediction files (CPF format)","title":"SlrPredictionParser"},{"location":"api/midgard-parsers/#midgardparsersspring_csv","text":"A parser for reading Spring CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='spring_csv', file_path='ADOP20473_0000.csv') data = p.as_dict() Description: Reads data from files in Spring CSV output format. The header information of the Spring CSV file is not read (TODO).","title":"midgard.parsers.spring_csv"},{"location":"api/midgard-parsers/#springcsvparser","text":"Full name: midgard.parsers.spring_csv.SpringCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Spring CSV output files The Spring CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the Spring CSV colum values. Depending on the Spring CSV following dataset fields can be available: Field Description acquiredsat Number of acquired satellites (TODO?) gdop Geometric dilution of precision hdop Horizontal dilution of precision pdop Position (3D) dilution of precision satinview Number of satellites in view system GNSS identifier based on RINEX definition (e.g. G: GPS, E: Galileo) tdop Time dilution of precision time Observation time given as Time object usedsat Number of used satellites vdop Vertical dilution of precision ... ...","title":"SpringCsvParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_position","text":"A parser for reading Terrapos position output file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_position', file_path='Gal_C1X_brdc_land_30sec_24hrs_FNAV-file.txt') data = p.as_dict() Description: Reads data from files in Terrapos position output format.","title":"midgard.parsers.terrapos_position"},{"location":"api/midgard-parsers/#terrapospositionparser","text":"Full name: midgard.parsers.terrapos_position.TerraposPositionParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Terrapos position output file Following data are available after reading Terrapos position file: Key Description gpsweek GPS week gpssec Seconds of GPS week head Head in [deg] height Ellipsoidal height in [m] lat Latitude in [deg] lon Longitude in [deg] num_sat Number of satellites pdop Position Dilution of Precision (PDOP) pitch Pitch in [deg] reliability_east East position external reliability in [m] #TODO: Is that correct? reliability_height Height position external reliability in [m] #TODO: Is that correct? reliability_north North position external reliability in [m] #TODO: Is that correct? roll Roll in [deg] sigma_east Standard deviation of East position in [m] #TODO: Is that correct? sigma_height Standard deviation of Height position in [m] #TODO: Is that correct? sigma_north Standard deviation of North position in [m] #TODO: Is that correct? and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposPositionParser"},{"location":"api/midgard-parsers/#midgardparsersterrapos_residual","text":"A parser for reading Terrapos residual file Example: from midgard import parsers p = parsers.parse_file(parser_name='terrapos_residual', file_path='PPP-residuals.txt') data = p.as_dict() Description: Reads data from files in Terrapos residual format.","title":"midgard.parsers.terrapos_residual"},{"location":"api/midgard-parsers/#terraposresidualparser","text":"Full name: midgard.parsers.terrapos_residual.TerraposResidualParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading Terrapos residual file Following data are available after reading Terrapos residual file: Parameter Description azimuth Azimuth of satellites in [deg] elevation Elevation of satellites in [deg] gpsweek GPS week gpssec Seconds of GPS week residual_code Code (pseudorange) residuals in [m] residual_doppler Doppler residuals in [m] residual_phase Carrier-phase residuals in [m] satellite Satellite PRN number together with GNSS identifier (e.g. G07) system GNSS identifier and meta -data: Key Description __data_path__ File path __parser_name__ Parser name","title":"TerraposResidualParser"},{"location":"api/midgard-parsers/#midgardparsersure_control_tool_csv","text":"A parser for reading URE Control Tool CSV output files Example: from midgard import parsers p = parsers.parse_file(parser_name='ure_control_tool_csv', file_path='G_GAL258_E1E5a_URE-AllPRN_190301.csv') data = p.as_dict() Description: Reads data from files in URE Control Tool CSV output format. The header information of the URE Control Tool CSV file is not read (TODO).","title":"midgard.parsers.ure_control_tool_csv"},{"location":"api/midgard-parsers/#urecontroltoolcsvparser","text":"Full name: midgard.parsers.ure_control_tool_csv.UreControlToolCsvParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading URE Control Tool CSV output files The URE Control Tool CSV data header line is used to define the keys of the data dictionary. The values of the data dictionary are represented by the URE Control Tool CSV colum values.","title":"UreControlToolCsvParser"},{"location":"api/midgard-parsers/#midgardparsersvlbi_source_names","text":"A parser for reading IVS source names translation table","title":"midgard.parsers.vlbi_source_names"},{"location":"api/midgard-parsers/#vlbisourcenamesparser","text":"Full name: midgard.parsers.vlbi_source_names.VlbiSourceNamesParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None) -> None A parser for reading IVS source names translation table See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file","title":"VlbiSourceNamesParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex","text":"A parser for reading Rinex files","title":"midgard.parsers.wip_rinex"},{"location":"api/midgard-parsers/#rinex","text":"Full name: midgard.parsers.wip_rinex.rinex Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on Rinex file type","title":"rinex()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav","text":"A parser for reading RINEX navigation files with version 2.xx","title":"midgard.parsers.wip_rinex2_nav"},{"location":"api/midgard-parsers/#rinex2navparser_1","text":"Full name: midgard.parsers.wip_rinex2_nav.Rinex2NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 2.xx","title":"Rinex2NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_nav_header","text":"RINEX navigation header classes for file format version 2.xx","title":"midgard.parsers.wip_rinex2_nav_header"},{"location":"api/midgard-parsers/#rinex2navheadermixin","text":"Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex2navheaderparser","text":"Full name: midgard.parsers.wip_rinex2_nav_header.Rinex2NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex2NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs","text":"A parser for reading RINEX observation files with version 2.xx","title":"midgard.parsers.wip_rinex2_obs"},{"location":"api/midgard-parsers/#rinex2obsparser","text":"Full name: midgard.parsers.wip_rinex2_obs.Rinex2ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 2.xx","title":"Rinex2ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex2_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex2_obs_header"},{"location":"api/midgard-parsers/#rinex2obsheadermixin","text":"Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 2.xx","title":"Rinex2ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex2obsheaderparser","text":"Full name: midgard.parsers.wip_rinex2_obs_header.Rinex2ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 2.xx observation header The data in the rinex file will not be parsed.","title":"Rinex2ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_clk","text":"A parser for reading RINEX clock files with version 3.xx","title":"midgard.parsers.wip_rinex3_clk"},{"location":"api/midgard-parsers/#rinex3clkparser","text":"Full name: midgard.parsers.wip_rinex3_clk.Rinex3ClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX clock files with version 3.xx","title":"Rinex3ClkParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_clk_header","text":"RINEX clock header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_clk_header"},{"location":"api/midgard-parsers/#rinex3clkheadermixin","text":"Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderMixin Signature: () A mixin defining which RINEX clock headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ClkHeaderMixin"},{"location":"api/midgard-parsers/#rinex3clkheaderparser","text":"Full name: midgard.parsers.wip_rinex3_clk_header.Rinex3ClkHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx clock header The data in the rinex file will not be parsed.","title":"Rinex3ClkHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav","text":"A parser for reading RINEX navigation files with version 3.xx","title":"midgard.parsers.wip_rinex3_nav"},{"location":"api/midgard-parsers/#rinex3navparser_1","text":"Full name: midgard.parsers.wip_rinex3_nav.Rinex3NavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX navigation files with version 3.xx","title":"Rinex3NavParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_nav_header","text":"RINEX navigation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_nav_header"},{"location":"api/midgard-parsers/#rinex3navheadermixin","text":"Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderMixin Signature: () A mixin defining which RINEX navigation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3NavHeaderMixin"},{"location":"api/midgard-parsers/#rinex3navheaderparser","text":"Full name: midgard.parsers.wip_rinex3_nav_header.Rinex3NavHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx navigation header The data in the rinex file will not be parsed.","title":"Rinex3NavHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs","text":"A parser for reading RINEX observation files with version 3.xx","title":"midgard.parsers.wip_rinex3_obs"},{"location":"api/midgard-parsers/#rinex3obsparser","text":"Full name: midgard.parsers.wip_rinex3_obs.Rinex3ObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading RINEX observation files with version 3.xx","title":"Rinex3ObsParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex3_obs_header","text":"RINEX observation header classes for file format version 3.xx","title":"midgard.parsers.wip_rinex3_obs_header"},{"location":"api/midgard-parsers/#rinex3obsheadermixin","text":"Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderMixin Signature: () A mixin defining which RINEX observation headers are mandatory and optional in RINEX version 3.xx","title":"Rinex3ObsHeaderMixin"},{"location":"api/midgard-parsers/#rinex3obsheaderparser","text":"Full name: midgard.parsers.wip_rinex3_obs_header.Rinex3ObsHeaderParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None A parser for reading just the RINEX version 3.xx observation header The data in the rinex file will not be parsed.","title":"Rinex3ObsHeaderParser"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_clk","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_clk"},{"location":"api/midgard-parsers/#rinexclkparser","text":"Full name: midgard.parsers.wip_rinex_clk.RinexClkParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX clock parsers.","title":"RinexClkParser"},{"location":"api/midgard-parsers/#rinex_clk","text":"Full name: midgard.parsers.wip_rinex_clk.rinex_clk Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_clk()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_nav","text":"A parser for reading Rinex navigation files","title":"midgard.parsers.wip_rinex_nav"},{"location":"api/midgard-parsers/#rinexnavparser","text":"Full name: midgard.parsers.wip_rinex_nav.RinexNavParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX navigation parsers.","title":"RinexNavParser"},{"location":"api/midgard-parsers/#rinex_nav","text":"Full name: midgard.parsers.wip_rinex_nav.rinex_nav Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_nav()"},{"location":"api/midgard-parsers/#midgardparserswip_rinex_obs","text":"A parser for reading Rinex observation files","title":"midgard.parsers.wip_rinex_obs"},{"location":"api/midgard-parsers/#rinexobsparser","text":"Full name: midgard.parsers.wip_rinex_obs.RinexObsParser Signature: (file_path: Union[str, pathlib.Path], encoding: Union[str, NoneType] = None, logger=<built-in function print>, sampling_rate: Union[int, NoneType] = None, strict: bool = False) -> None Class for defining common methods for RINEX observation parsers.","title":"RinexObsParser"},{"location":"api/midgard-parsers/#rinex_obs","text":"Full name: midgard.parsers.wip_rinex_obs.rinex_obs Signature: (**parser_args: Any) -> midgard.parsers._parser_rinex.RinexParser Dispatch to correct subclass based on version in Rinex file","title":"rinex_obs()"},{"location":"api/midgard-plot/","text":"midgard.plot midgard.plot.matplotext Matplotlib extension class Description: Wrapper functions around matplotlib subroutines are defined in this class. MatPlotExt Full name: midgard.plot.matplotext.MatPlotExt Signature: (options: Dict[str, Any] = None) -> None Class for plotting - Extension of matplotlib Following options * can be selected: Option Value Description colormap Color map type for plotting either events or labels (e.g. viridis, jet, tab10, rainbow, hsv, plasma) dpi Resolution of file in dots per inch figsize (num, num) Figure size given by (width, height) in inches fsize_subtitle Fontsize of subplot title (statistical information) grid <True False> histogram Plot x-axis histogram on top, y-axis histogram on right or for both axis on scatter plot histogram_binwidth Histogram bin width histogram_size Histogram y-axis size legend <True False> legend_location Legend location legend_ncol The number of legend columns linestyle","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplot","text":"","title":"midgard.plot"},{"location":"api/midgard-plot/#midgardplotmatplotext","text":"Matplotlib extension class Description: Wrapper functions around matplotlib subroutines are defined in this class.","title":"midgard.plot.matplotext"},{"location":"api/midgard-plot/#matplotext","text":"Full name: midgard.plot.matplotext.MatPlotExt Signature: (options: Dict[str, Any] = None) -> None Class for plotting - Extension of matplotlib Following options * can be selected: Option Value Description colormap Color map type for plotting either events or labels (e.g. viridis, jet, tab10, rainbow, hsv, plasma) dpi Resolution of file in dots per inch figsize (num, num) Figure size given by (width, height) in inches fsize_subtitle Fontsize of subplot title (statistical information) grid <True False> histogram Plot x-axis histogram on top, y-axis histogram on right or for both axis on scatter plot histogram_binwidth Histogram bin width histogram_size Histogram y-axis size legend <True False> legend_location Legend location legend_ncol The number of legend columns linestyle","title":"MatPlotExt"},{"location":"api/midgard-site_info/","text":"midgard.site_info midgard.site_info.antenna Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date. Example: from midgard.site_info import antenna; from datetime import datetime antenna.Antenna.get(source=\"sinex\", station=\"zimm\", date=datetime(2018, 10, 1), source_path=\"igs.snx\") Antenna Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file. AntennaBase Full name: midgard.site_info.antenna.AntennaBase Signature: (station: str, antenna_info: Dict[str, Any]) -> None Antenna base class defining common attributes and methods AntennaHistory Full name: midgard.site_info.antenna.AntennaHistory Signature: () AntennaHistoryBase Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver) AntennaHistorySinex Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station: str, source_path: str) -> None AntennaSinex Full name: midgard.site_info.antenna.AntennaSinex Signature: (station: str, antenna_info: Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information midgard.site_info.receiver Receiver site information classes Description: The receiver module generates a receiver object based on site information from the SINEX file or other sources. Following steps are carried out for getting a receiver object: 1. Plugins modulen register ReceiverHistory classes (e.g. ReceiverHistorySinex) and updates the 'sources' attribute of the ReceiverHistory class. 2. The Receiver object is initialized by calling the Receiver.get function. 3. The ReceiverHistory.get function is called via the Receiver.get function. Here the correct ReceiverHistory class is choosen by accessing the registered 'sources' attribute of the ReceiverHistory class. 4. The ReceiverBase.get function reads the receiver information via the _read_history() function of the ReceiverHistorySinex or other calls. The receiver information is selected via a given date. Example: from midgard.site_info import receiver receiver.Receiver.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1), source_path=\"igs.snx\") Receiver Full name: midgard.site_info.receiver.Receiver Signature: () Main receiver class for getting receiver object depending on site information source The site information source can be e.g. a SINEX file. ReceiverBase Full name: midgard.site_info.receiver.ReceiverBase Signature: (station: str, receiver_info: Dict[str, Any]) -> None Receiver base class defining common attributes and methods ReceiverHistory Full name: midgard.site_info.receiver.ReceiverHistory Signature: () ReceiverHistoryBase Full name: midgard.site_info.receiver.ReceiverHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver) ReceiverHistorySinex Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station: str, source_path: str) -> None ReceiverSinex Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station: str, receiver_info: Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information midgard.site_info.site_info Basic functionality for parsing and saving site information Description: This module contains functions and classes for parsing site information. This file defines the general structure shared by site information types. More specific format details are implemented in subclasses. SiteInfoHistory Full name: midgard.site_info.site_info.SiteInfoHistory Signature: () SiteInfoHistoryBase Full name: midgard.site_info.site_info.SiteInfoHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_info","text":"","title":"midgard.site_info"},{"location":"api/midgard-site_info/#midgardsite_infoantenna","text":"Antenna site information classes Description: The antenna module generates a antenna object based on site information from the SINEX file or other sources. Following steps are carried out for getting a antenna object: 1. Plugins modulen register AntennaHistory classes (e.g. AntennaHistorySinex) and updates the 'sources' attribute of the AntennaHistory class. 2. The Antenna object is initialized by calling the Antenna.get function. 3. The AntennaHistory.get function is called via the Antenna.get function. Here the correct AntennaHistory class is choosen by accessing the registered 'sources' attribute of the AntennaHistory class. 4. The AntennaBase.get function reads the antenna information via the _read_history() function of the AntennaHistorySinex or other calls. The antenna information is selected via a given date. Example: from midgard.site_info import antenna; from datetime import datetime antenna.Antenna.get(source=\"sinex\", station=\"zimm\", date=datetime(2018, 10, 1), source_path=\"igs.snx\")","title":"midgard.site_info.antenna"},{"location":"api/midgard-site_info/#antenna","text":"Full name: midgard.site_info.antenna.Antenna Signature: () Main antenna class for getting antenna object depending on site information source The site information source can be e.g. a SINEX file.","title":"Antenna"},{"location":"api/midgard-site_info/#antennabase","text":"Full name: midgard.site_info.antenna.AntennaBase Signature: (station: str, antenna_info: Dict[str, Any]) -> None Antenna base class defining common attributes and methods","title":"AntennaBase"},{"location":"api/midgard-site_info/#antennahistory","text":"Full name: midgard.site_info.antenna.AntennaHistory Signature: ()","title":"AntennaHistory"},{"location":"api/midgard-site_info/#antennahistorybase","text":"Full name: midgard.site_info.antenna.AntennaHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"AntennaHistoryBase"},{"location":"api/midgard-site_info/#antennahistorysinex","text":"Full name: midgard.site_info.antenna.AntennaHistorySinex Signature: (station: str, source_path: str) -> None","title":"AntennaHistorySinex"},{"location":"api/midgard-site_info/#antennasinex","text":"Full name: midgard.site_info.antenna.AntennaSinex Signature: (station: str, antenna_info: Dict[str, Any]) -> None Antenna class handling SINEX file antenna station information","title":"AntennaSinex"},{"location":"api/midgard-site_info/#midgardsite_inforeceiver","text":"Receiver site information classes Description: The receiver module generates a receiver object based on site information from the SINEX file or other sources. Following steps are carried out for getting a receiver object: 1. Plugins modulen register ReceiverHistory classes (e.g. ReceiverHistorySinex) and updates the 'sources' attribute of the ReceiverHistory class. 2. The Receiver object is initialized by calling the Receiver.get function. 3. The ReceiverHistory.get function is called via the Receiver.get function. Here the correct ReceiverHistory class is choosen by accessing the registered 'sources' attribute of the ReceiverHistory class. 4. The ReceiverBase.get function reads the receiver information via the _read_history() function of the ReceiverHistorySinex or other calls. The receiver information is selected via a given date. Example: from midgard.site_info import receiver receiver.Receiver.get(source=\"sinex\", station=\"ales\", date=datetime(2018, 10, 1), source_path=\"igs.snx\")","title":"midgard.site_info.receiver"},{"location":"api/midgard-site_info/#receiver","text":"Full name: midgard.site_info.receiver.Receiver Signature: () Main receiver class for getting receiver object depending on site information source The site information source can be e.g. a SINEX file.","title":"Receiver"},{"location":"api/midgard-site_info/#receiverbase","text":"Full name: midgard.site_info.receiver.ReceiverBase Signature: (station: str, receiver_info: Dict[str, Any]) -> None Receiver base class defining common attributes and methods","title":"ReceiverBase"},{"location":"api/midgard-site_info/#receiverhistory","text":"Full name: midgard.site_info.receiver.ReceiverHistory Signature: ()","title":"ReceiverHistory"},{"location":"api/midgard-site_info/#receiverhistorybase","text":"Full name: midgard.site_info.receiver.ReceiverHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"ReceiverHistoryBase"},{"location":"api/midgard-site_info/#receiverhistorysinex","text":"Full name: midgard.site_info.receiver.ReceiverHistorySinex Signature: (station: str, source_path: str) -> None","title":"ReceiverHistorySinex"},{"location":"api/midgard-site_info/#receiversinex","text":"Full name: midgard.site_info.receiver.ReceiverSinex Signature: (station: str, receiver_info: Dict[str, Any]) -> None Receiver class handling SINEX file receiver station information","title":"ReceiverSinex"},{"location":"api/midgard-site_info/#midgardsite_infosite_info","text":"Basic functionality for parsing and saving site information Description: This module contains functions and classes for parsing site information. This file defines the general structure shared by site information types. More specific format details are implemented in subclasses.","title":"midgard.site_info.site_info"},{"location":"api/midgard-site_info/#siteinfohistory","text":"Full name: midgard.site_info.site_info.SiteInfoHistory Signature: ()","title":"SiteInfoHistory"},{"location":"api/midgard-site_info/#siteinfohistorybase","text":"Full name: midgard.site_info.site_info.SiteInfoHistoryBase Signature: (station: str, source_path: str) -> None History base class defining common attributes and methods from a specific site information (e.g. antenna, receiver)","title":"SiteInfoHistoryBase"},{"location":"api/midgard-writers/","text":"midgard.writers Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ... names () Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers. write () Full name: midgard.writers.write Signature: (writer: str, **writer_args: Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer. midgard.writers._writers Basic functionality for writing files Description: This module contains functions for writing files. get_existing_fields () Full name: midgard.writers._writers.get_existing_fields Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Writer fields. Returns: Existing writer fields get_existing_fields_by_attrs () Full name: midgard.writers._writers.get_existing_fields_by_attrs Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Fields to write/plot. Returns: Existing writer fields get_field () Full name: midgard.writers._writers.get_field Signature: (dset: 'Dataset', field: str, attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. field : Field name. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values get_field_by_attrs () Full name: midgard.writers._writers.get_field_by_attrs Signature: (dset: 'Dataset', attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values get_header () Full name: midgard.writers._writers.get_header Signature: (fields: List[str], pgm_version: Union[NoneType, str] = None, run_by: str = '', summary: Union[NoneType, str] = None, add_description: Union[NoneType, str] = None, lsign: str = '') -> str Get header Args: fields : List with fields to write. pgm_version : Name and version (e.g. where 1.0.0) of program, which has created the output. run_by : Information about who has created this file (e.g. NMA). summary : Short description of output file add_description : Additional description lines lsign : Leading comment sign Returns: Header lines","title":"midgard.writers"},{"location":"api/midgard-writers/#midgardwriters","text":"Framework for writing output in different formats Description: Each output format / output destination should be defined in a separate .py-file. The function inside the .py-file that should be called need to be decorated with the :func: ~midgard.dev.plugins.register decorator as follows:: from midgard.dev import plugins @plugins.register def write_as_fancy_format(arg_1, arg_2): ...","title":"midgard.writers"},{"location":"api/midgard-writers/#names","text":"Full name: midgard.writers.names Signature: () -> List[str] List the names of the available writers Returns: List of strings with the names of the available writers.","title":"names()"},{"location":"api/midgard-writers/#write","text":"Full name: midgard.writers.write Signature: (writer: str, **writer_args: Any) -> None Call one writer Args: writer : Name of writer. writer_args : Arguments passed on to writer.","title":"write()"},{"location":"api/midgard-writers/#midgardwriters_writers","text":"Basic functionality for writing files Description: This module contains functions for writing files.","title":"midgard.writers._writers"},{"location":"api/midgard-writers/#get_existing_fields","text":"Full name: midgard.writers._writers.get_existing_fields Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Writer fields. Returns: Existing writer fields","title":"get_existing_fields()"},{"location":"api/midgard-writers/#get_existing_fields_by_attrs","text":"Full name: midgard.writers._writers.get_existing_fields_by_attrs Signature: (dset: 'Dataset', writers_in: Tuple[ForwardRef('WriterField'), ...]) -> Tuple[ForwardRef('WriterField'), ...] Get existing writer fields, which are given in Dataset. Args: dset : Dataset, a dataset containing the data. writers_in : Fields to write/plot. Returns: Existing writer fields","title":"get_existing_fields_by_attrs()"},{"location":"api/midgard-writers/#get_field","text":"Full name: midgard.writers._writers.get_field Signature: (dset: 'Dataset', field: str, attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. field : Field name. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values","title":"get_field()"},{"location":"api/midgard-writers/#get_field_by_attrs","text":"Full name: midgard.writers._writers.get_field_by_attrs Signature: (dset: 'Dataset', attrs: Tuple[str], unit: str) -> numpy.ndarray Get field values of a Dataset specified by the field attributes If necessary the unit of the data fields are corrected to the defined 'output' unit. Args: dset : Dataset, a dataset containing the data. attrs : Field attributes (e.g. for Time object: ( , )). unit : Unit used for output. Returns: Array with Dataset field values","title":"get_field_by_attrs()"},{"location":"api/midgard-writers/#get_header","text":"Full name: midgard.writers._writers.get_header Signature: (fields: List[str], pgm_version: Union[NoneType, str] = None, run_by: str = '', summary: Union[NoneType, str] = None, add_description: Union[NoneType, str] = None, lsign: str = '') -> str Get header Args: fields : List with fields to write. pgm_version : Name and version (e.g. where 1.0.0) of program, which has created the output. run_by : Information about who has created this file (e.g. NMA). summary : Short description of output file add_description : Additional description lines lsign : Leading comment sign Returns: Header lines","title":"get_header()"},{"location":"api/midgard/","text":"midgard Midgard, the Python Geodesy library Midgard is a collection of useful Python utilities used by the Geodetic institute at the Norwegian Mapping Authority (Kartverket). Although some of these are geodesy-specific, many are also useful in more general settings. Note: Midgard is still in pre-alpha status. Its functionality will change, and it should not be depended on in any production-like setting. Midgard comes organized into different subpackages: collections config data dev files gnss ionosphere math parsers plot site_info writers Look for help inside each subpackage: >>> from midgard import subpackage # doctest: +SKIP >>> help(subpackage) # doctest: +SKIP Current maintainers: Michael D\u00e4hnn michael.daehnn@kartverket.no Ingrid Fausk ingrid.fausk@kartverket.no Ann-Silje Kirkvik ann-silje.kirkvik@kartverket.no Mohammed Ouassou mohammed.ouassou@kartverket.no Hans Sverre Smal\u00f8 hans.sverre.smalo@kartverket.no Geir Arne Hjelle geirarne@gmail.com","title":"midgard"},{"location":"howto/testing/","text":"Testing It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"},{"location":"howto/testing/#testing","text":"It will be shortly described how the source code testing is done in Midgard. pytest is used by Midgard for testing the library modules. All module tests of Midgard are located in directory ./midgard/tests . The tests directory mirrors the official directory structure under ./midgard/midgard . For example the test for the modul ./midgard/midgard/math/interpolation.py can be found under ./midgard/tests/math/test_interpolation.py . In Midgard the test files follow the naming convention test_<module name>.py (e.g. test_interpolation.py ). Information about how to write pytest tests can be found under https://pytest.org/ . The written test can be excecuted as follows: All Midgard tests can be excecuted by calling make test in main directory ./midgard . If no arguments are specified pytest searches recursively after test_*.py files starting from the current directory. A single modul test can be carried out for example by pytest tests/ionosphere/test_klobuchar.py . An overview over passed and failed tests are given after excecuting pytest .","title":"Testing"}]}